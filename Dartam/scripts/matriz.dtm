tupla matriz3 A, B, resultado; // Definir matrices

tupla matriz3 {
	inmut ent filas: 3, columnas: 3;
	ent [3][3] datos;
}

f vacio inicio(car[][] argumentos) {
 
	tupla matriz3 A;
    // Inicializar matrices A y B
    inicializarMatriz(A, 3);
    inicializarMatriz(B, 2);
    
    // Multiplicar matrices A y B
    tupla matriz3 resultado: multiplicarMatrices(A, B);
    
    // Mostrar resultado
    mostrarMatriz(resultado);
}

f vacio inicializarMatriz(tupla matriz3 m, ent modo) {
	inmut ent c: modo;
	loop ent i: 0; i < m.filas; i++ {
		loop ent j: 0; j < m.columnas; j++ {
			ent[m.filas][m.columnas] aux: m.datos;
			aux[i][j]: (i+j)\c;
		}
	}
}

f tupla matriz3 multiplicarMatrices(tupla matriz3 A, tupla matriz3 B) {
	tupla matriz3 C;
    // Verificar si las matrices son multiplicables
    si ¬(A.columnas = B.filas) {
        // Las matrices no son compatibles para la multiplicación
        // Puedes manejar este caso de acuerdo a tus necesidades
        show("No se pueden multiplicar estas matrices.");
        pop C;
    }
	
    // Inicializar matriz resultado con ceros
    inicializarMatriz(C, 0);

    // Realizar la multiplicación de matrices
    loop (ent i: 0; i < A.filas; i++) {
        loop ((ent j: 0; j < B.columnas; j++)) {
            loop (ent k: 0; (k < A.columnas); k++) {
				ent[A.filas][A.columnas] auxA: A.datos;
				ent[B.filas][B.columnas] auxB: B.datos;
				ent[A.filas][B.columnas] auxC: C.datos;
                auxC[i][j]: auxC[i][j] + auxA[i][k] * auxB[k][j];
            }
        }
    }
	pop C;
}

f vacio mostrarMatriz(tupla matriz3 m) {
    loop ent i: 0; i < m.filas; i++ {
        loop ent j: 0; j < m.columnas; j++ {
			ent[m.filas][m.columnas] aux: m.datos;
            show((car[])(car)aux[i][j] + " ");
			# car[] s: (car[])(car)aux[i][j]; show(s + " "); #
        }
		show("\n");
    }
}