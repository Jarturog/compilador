
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Arturo, Dani y Marta
 */
package analizadorSintactico;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;
import java_cup.runtime.ComplexSymbolFactory.Location;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{ 
        report_error("Error síntactico irrecuperable en la Línea " + 
        (cur_token.left)+ " Columna "+cur_token.right+". Componente " + cur_token.value + 
        " no reconocido.", cur_token); 
        done_parsing();
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    @Override
    public void syntax_error(Symbol cur_token){ 
        report_error("Error Sintáctico en la Línea " + (cur_token.left) +
        " Columna "+cur_token.right+ ". No se esperaba este componente: " +cur_token.value+".", cur_token); 
    } 

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }

:}

/****
    També aquí es poden afegir accions a realitzar quan es requereix un token.
    scan with {:     next_token(); :}
**/

terminal    OP_INC, OP_DEC, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD;
terminal    AS_ASSIGN, AS_ADDA, AS_SUBA, AS_MULA, AS_DIVA, AS_POTA, AS_ANDA, AS_ORA;
terminal    OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
terminal    OP_AND, OP_OR, OP_NOT;
terminal    OP_SWAP, OP_PCT, OP_POT, OP_COND, ARROW, OP_MEMBER;
terminal    KW_BOOL, KW_INT, KW_DOUBLE, KW_CHAR, KW_STRING, KW_VOID;
terminal    LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, ENDINSTR, COMMA;
terminal    KW_MAIN, KW_ARGS, KW_METHOD, KW_TUPLE, KW_CONST, KW_IF, KW_ELIF, KW_ELSE, KW_LOOP, KW_DO, KW_SWITCH, KW_RETURN, KW_IN, KW_OUT, KW_READ, KW_WRITE, KW_CASE, KW_DEFAULT;
terminal    AUX_MEMBER;

terminal    String              ID, STRING;
terminal    Boolean             BOOL;
terminal    Integer             INT;
terminal    Double              DOUBLE;
terminal    Character           CHAR;

non terminal SymbolBody BODY;
non terminal SymbolMain MAIN;
non terminal SymbolMethod METHOD;
non terminal SymbolTypeRetorno TIPO_RETORNO;
non terminal SymbolTypeVar TIPO_VAR;
non terminal SymbolGetParams GETPARAMS;
non terminal SymbolParam PARAM;
non terminal SymbolDecs DECS;
non terminal SymbolIDDecsLista IDDECSLISTA;
non terminal SymbolAsig ASIG;
non terminal SymbolElementoMetodo ELEMENTO_METODO;
non terminal SymbolInstr INSTR;
non terminal SymbolFCall FCALL;
non terminal SymbolFName FNAME;
non terminal SymbolSetParams SETPARAMS;
non terminal SymbolOperandsLista OPERANDSLISTA;
non terminal SymbolReturn RETURN;
non terminal SymbolSwap SWAP;
non terminal SymbolAsigs ASIGS;
non terminal SymbolIDAsigLista IDASIGLISTA;
non terminal SymbolAsOp AS_OP;
non terminal SymbolOperand OPERAND;
non terminal SymbolUnaryExpression UNARY_EXPRESSION;
non terminal SymbolBinaryExpression BINARY_EXPRESSION;
non terminal SymbolConditionalExpression CONDITIONAL_EXPRESSION;
non terminal SymbolAtomicExpression ATOMIC_EXPRESSION;
non terminal SymbolBinaryOperator BINARY_OPERATOR;
non terminal SymbolUnaryOperator UNARY_OPERATOR;
non terminal SymbolLoop LOOP;
non terminal SymbolLoopCond LOOP_COND;
non terminal SymbolIf IF;
non terminal SymbolElifs ELIFS;
non terminal SymbolElif ELIF;
non terminal SymbolElse ELSE;
non terminal SymbolSwitch SWITCH;
non terminal SymbolCaso CASO;
non terminal SymbolPred PRED;
non terminal SymbolScript SCRIPT;
non terminal SymbolMethodsBeforeMain SCRIPTBM;
non terminal SymbolMethodsAfterMain SCRIPTAM;
non terminal SymbolDimensiones DIMENSIONES;

precedence left OP_ADD, OP_SUB;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence right OP_POT;
precedence left OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
precedence left OP_AND, OP_OR;
precedence right OP_COND;
precedence left OP_MEMBER, AUX_MEMBER;

start with SCRIPT;

SCRIPT ::= SCRIPTBM:et1 SCRIPT:et2              {: RESULT = new SymbolMethodsBeforeMain(); :}
        | SCRIPTAM:et                           {: RESULT = new SymbolMethodsAfterMain(); :}
        ;

SCRIPTBM ::= METHOD:et                          {: RESULT = new SymbolMethod(); :}
        | DECS:et                               {: RESULT = new SymbolDecs(); :}
        ;

SCRIPTAM ::= MAIN:et                            {: RESULT = new SymbolMain(); :}
        | SCRIPTAM:et1 SCRIPTBM:et2             {: ; :}
        ;

MAIN ::= KW_MAIN LPAREN KW_CHAR LBRACKET RBRACKET LBRACKET RBRACKET KW_ARGS RPAREN LKEY BODY:et RKEY {: RESULT = new SymbolBody(); :}
        ;

METHOD ::= KW_METHOD TIPO_RETORNO:et1 ID LPAREN GETPARAMS:et2 RPAREN LKEY BODY:et3 RKEY {: RESULT = new SymbolBody(); :}
        ;

BODY ::= ELEMENTO_METODO:et1 BODY:et2           {: RESULT = et1 + " " et2; :}
        |                                       {: RESULT = ""; :}
        ;

TIPO_RETORNO ::= TIPO_VAR:et                    {: RESULT = et; :}
        | KW_VOID                               {: RESULT = "void"; :}
        ;

TIPO_VAR ::= KW_BOOL                            {: RESULT = "bool"; :}
        | KW_INT                                {: RESULT = "int"; :}
        | KW_DOUBLE                             {: RESULT = "double"; :}
        | KW_CHAR                               {: RESULT = "char"; :}
        | KW_STRING                             {: RESULT = "string"; :}
        ;

GETPARAMS ::= PARAM:et1 COMMA GETPARAMS:et2     {: RESULT = et1 + ", " + et2; :}
        | PARAM:et                              {: RESULT = et; :}
        |                                       {: RESULT = ""; :}
        ;

PARAM ::= TIPO_VAR:et1 ID:et2                   {: RESULT = et1 + " " + et2; :}
        ;

DECS ::= KW_CONST TIPO_VAR:et1 IDDECSLISTA:et2 ENDINSTR  {: RESULT = "const " + et1 + " " + et2; :}
        | TIPO_VAR:et1 IDDECSLISTA:et2 ENDINSTR          {: RESULT = et1 + " " + et2; :}
        | KW_CONST TIPO_VAR:et1 DIMENSIONES:et2 IDDECSLISTA:et3 ENDINSTR {: RESULT = "const " + et1 + " " + et2 + " " + et3; :}
        | TIPO_VAR:et1 DIMENSIONES:et2 IDDECSLISTA:et3 ENDINSTR {: RESULT = et1 + " " + et2 + " " + et3; :}
        | KW_TUPLE ID LKEY RKEY ENDINSTR                 {: RESULT = "tuple " + ID; :}
        | KW_TUPLE ID LKEY IDDECSLISTA:et RKEY ENDINSTR  {: RESULT = "tuple " + ID + " " + et; :}
        ;

DIMENSIONES ::= LBRACKET OPERAND:et1 RBRACKET DIMENSIONES:et2 {: RESULT = "[" + et1 + "]" + et2; :}
        | LBRACKET OPERAND:et RBRACKET                 {: RESULT = "[" + et + "]"; :}
        ;

IDDECSLISTA ::= ID ASIG:et1 COMMA IDDECSLISTA:et2       {: RESULT = et1 + ", " + et2; :}
        | ID ASIG:et                                    {: RESULT = et; :}
        ;

ASIG ::= AS_ASSIGN:et1 OPERAND:et2      {: RESULT = et1 + " " + et2; :}
        |                               {: RESULT = ""; :}
        ;

ELEMENTO_METODO ::= INSTR:et           {: RESULT = et; :}
        | LOOP:et                      {: RESULT = et; :}
        | IF:et                        {: RESULT = et; :}
        | SWITCH:et                    {: RESULT = et; :}
        ;

INSTR ::= FCALL:et ENDINSTR             {: RESULT = et; :}
        | RETURN:et                     {: RESULT = et; :}
        | DECS:et                       {: RESULT = et; :}
        | ASIGS:et                      {: RESULT = et; :}
        | SWAP:et                       {: RESULT = et; :}
        ;

FCALL ::= FNAME:et1 LPAREN SETPARAMS:et2 RPAREN {: RESULT = et1 + "(" + et2 + ")"; :}
        ;

FNAME ::= ID:et                 {: RESULT = et; :}
        | KW_IN                 {: RESULT = "in"; :}
        | KW_OUT                {: RESULT = "out"; :}
        | KW_WRITE              {: RESULT = "write"; :}
        | KW_READ               {: RESULT = "read"; :}
        ;

SETPARAMS ::= OPERANDSLISTA:et  {: RESULT = et; :}
        |                       {: RESULT = ""; :}
        ;

OPERANDSLISTA ::= OPERAND:et1 COMMA OPERANDSLISTA:et2   {: RESULT = et1 + ", " + et2; :}
        | OPERAND:et                                    {: RESULT = et; :}
        ;

RETURN ::= KW_RETURN ENDINSTR                   {: RESULT = "return"; :}
        | KW_RETURN OPERAND:et ENDINSTR         {: RESULT = "return " + et; :}
        ;

SWAP ::= OPERAND:et1 OP_SWAP OPERAND:et2 ENDINSTR {: RESULT = et1 + " " + OP_SWAP + " " + et2; :}
        ;

ASIGS ::= IDASIGLISTA:et ENDINSTR              {: RESULT = et; :}
        ;

IDASIGLISTA ::= ID:et1 AS_OP:et2 OPERAND:et3 COMMA IDASIGLISTA:et4 {: RESULT = et1 + " " + et2 + " " + et3 + ", " + et4; :}
        | ID:et1 AS_OP:et2 OPERAND:et3          {: RESULT = et1 + " " + et2 + " " + et3; :}
        ;

AS_OP ::= AS_ASSIGN:et  {: RESULT = et; :}
        | AS_ADDA:et    {: RESULT = et; :}
        | AS_SUBA:et    {: RESULT = et; :}
        | AS_MULA:et    {: RESULT = et; :}
        | AS_DIVA:et    {: RESULT = et; :}
        | AS_POTA:et    {: RESULT = et; :}
        | AS_ANDA:et    {: RESULT = et; :}
        | AS_ORA:et     {: RESULT = et; :}
        ;

OPERAND ::= ATOMIC_EXPRESSION:et        {: RESULT = et; :}
        | FCALL:et                      {: RESULT = et; :}
        | LPAREN OPERAND:et RPAREN      {: RESULT = "(" + et + ")"; :}
        | UNARY_EXPRESSION:et           {: RESULT = et; :}
        | BINARY_EXPRESSION:et          {: RESULT = et; :}
        | CONDITIONAL_EXPRESSION:et     {: RESULT = et; :}
        | OPERAND:et1 AUX_MEMBER LBRACKET OPERAND:et2 RBRACKET {: RESULT = et1 + "[" + et2 + "]"; :}
        | OPERAND:et1 OP_MEMBER ID:et2  {: RESULT = et1 + "." + et2; :}
        ;

UNARY_EXPRESSION ::= UNARY_OPERATOR:et1 OPERAND:et2 {: RESULT = et1 + " " + et2; :}
        ;

BINARY_EXPRESSION ::= OPERAND:et1 BINARY_OPERATOR:et2 OPERAND:et3 {: RESULT = et1 + " " + et2 + " " + et3; :}
        ;

CONDITIONAL_EXPRESSION ::= OPERAND:et1 OP_COND OPERAND:et2 ARROW OPERAND:et3 {: RESULT = et1 + " " + et2 + " " + et3; :}
        ;

ATOMIC_EXPRESSION ::= ID:et     {: RESULT = et; :}
        | STRING:et             {: RESULT = et; :}
        | BOOL:et               {: RESULT = et; :}
        | INT:et                {: RESULT = et; :}
        | DOUBLE:et             {: RESULT = et; :}
        | CHAR:et               {: RESULT = et; :}
        ;

BINARY_OPERATOR ::= OP_ADD:et   {: RESULT = et; :}
        | OP_SUB:et             {: RESULT = et; :}
        | OP_MUL:et             {: RESULT = et; :}
        | OP_DIV:et             {: RESULT = et; :}
        | OP_MOD:et             {: RESULT = et; :}
        | OP_POT:et             {: RESULT = et; :}
        | OP_EQ:et              {: RESULT = et; :}
        | OP_BEQ:et             {: RESULT = et; :}
        | OP_BT:et              {: RESULT = et; :}
        | OP_LEQ:et             {: RESULT = et; :}
        | OP_LT:et              {: RESULT = et; :}
        | OP_NEQ:et             {: RESULT = et; :}
        | OP_AND:et             {: RESULT = et; :}
        | OP_OR:et              {: RESULT = et; :}
        ;

UNARY_OPERATOR ::= OP_NOT:et    {: RESULT = et; :}
        | OP_INC:et             {: RESULT = et; :}
        | OP_DEC:et             {: RESULT = et; :}
        | OP_PCT:et             {: RESULT = et; :}
        ;

LOOP ::= KW_LOOP LOOP_COND:et1 LKEY BODY:et2 RKEY {: RESULT = "loop " + et1 + " " + et2; :}
        | KW_DO LKEY BODY:et1 RKEY LOOP_COND:et2 ENDINSTR {: RESULT = "do " + et1 + " " + et2; :}
        ;

LOOP_COND ::= OPERAND:et             {: RESULT = et; :}
        | DECS ENDINSTR OPERAND:et1 ENDINSTR OPERAND:et2 {: RESULT = et1 + " " + et2; :}
        ;

IF ::= KW_IF OPERAND:et1 LKEY BODY:et2 RKEY ELIFS:et3 ELSE:et4 {: RESULT = "if " + et1 + " " + et2 + " " + et3 + " " + et4; :}
        ;

ELIFS ::= ELIF:et1 ELIFS:et2    {: RESULT = et1 + " " + et2; :}
        |                       {: RESULT = ""; :}
        ;

ELIF ::= KW_ELIF OPERAND:et1 LKEY BODY:et2 RKEY         {: RESULT = "elif " + et1 + " " + et2; :}
        ;

ELSE ::= KW_ELSE LKEY BODY:et RKEY      {: RESULT = "else " + et; :}
        |                               {: RESULT = ""; :}
        ;

SWITCH ::= KW_SWITCH OPERAND:et1 LKEY CASO:et2 PRED:et3 RKEY {: RESULT = et1 + " " + et2 + " " + et3; :}
        ;

CASO ::= CASO KW_CASE ARROW BODY:et      {: RESULT = et1; :}
        |                                {: RESULT = ""; :}
        ;

PRED ::= KW_CASE KW_DEFAULT ARROW BODY:et {: RESULT = et1; :}
        ;