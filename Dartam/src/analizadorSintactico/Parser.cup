
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Arturo, Dani y Marta
 */
package analizadorSintactico;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;
import java_cup.runtime.ComplexSymbolFactory.Location;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{ 
        report_error("Error síntactico irrecuperable en la Línea " + 
        (cur_token.left)+ " Columna "+cur_token.right+". Componente " + cur_token.value + 
        " no reconocido.", cur_token); 
        done_parsing();
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    @Override
    public void syntax_error(Symbol cur_token){ 
        report_error("Error Sintáctico en la Línea " + (cur_token.left) +
        " Columna "+cur_token.right+ ". No se esperaba este componente: " +cur_token.value+".", cur_token); 
    } 

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }

:}

/****
    També aquí es poden afegir accions a realitzar quan es requereix un token.
    scan with {:     next_token(); :}
**/

terminal    OP_INC, OP_DEC, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD;
terminal    AS_ASSIGN, AS_ADDA, AS_SUBA, AS_MULA, AS_DIVA, AS_POTA, AS_ANDA, AS_ORA;
terminal    OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
terminal    OP_AND, OP_OR, OP_NOT;
terminal    OP_SWAP, OP_PCT, OP_POT, OP_COND, ARROW, OP_MEMBER;
terminal    KW_BOOL, KW_INT, KW_DOUBLE, KW_CHAR, KW_STRING, KW_VOID;
terminal    LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, ENDINSTR, COMMA;
terminal    KW_MAIN, KW_ARGS, KW_METHOD, KW_TUPLE, KW_CONST, KW_IF, KW_ELIF, KW_ELSE, KW_LOOP, KW_DO, KW_SWITCH, KW_RETURN, KW_IN, KW_OUT, KW_READ, KW_WRITE, KW_CASE, KW_DEFAULT;
terminal    AUX_MEMBER;

terminal    String              ID, STRING;
terminal    Boolean             BOOL;
terminal    Integer             INT;
terminal    Double              DOUBLE;
terminal    Character           CHAR;

non terminal SymbolBody BODY;
non terminal SymbolMain MAIN;
non terminal SymbolMethod METHOD;
non terminal SymbolTypeRetorno TIPO_RETORNO;
non terminal SymbolTypeVar TIPO_VAR;
non terminal SymbolGetParams GETPARAMS;
non terminal SymbolParam PARAM;
non terminal SymbolDecs DECS;
non terminal SymbolIDDecsLista IDDECSLISTA;
non terminal SymbolAsig ASIG;
non terminal SymbolElementoMetodo ELEMENTO_METODO;
non terminal SymbolInstr INSTR;
non terminal SymbolFCall FCALL;
non terminal SymbolFName FNAME;
non terminal SymbolSetParams SETPARAMS;
non terminal SymbolOperandsLista OPERANDSLISTA;
non terminal SymbolReturn RETURN;
non terminal SymbolSwap SWAP;
non terminal SymbolAsigs ASIGS;
non terminal SymbolIDAsigLista IDASIGLISTA;
non terminal SymbolAsOp AS_OP;
non terminal SymbolOperand OPERAND;
non terminal SymbolUnaryExpression UNARY_EXPRESSION;
non terminal SymbolBinaryExpression BINARY_EXPRESSION;
non terminal SymbolConditionalExpression CONDITIONAL_EXPRESSION;
non terminal SymbolAtomicExpression ATOMIC_EXPRESSION;
non terminal SymbolBinaryOperator BINARY_OPERATOR;
non terminal SymbolUnaryOperator UNARY_OPERATOR;
non terminal SymbolLoop LOOP;
non terminal SymbolLoopCond LOOP_COND;
non terminal SymbolIf IF;
non terminal SymbolElifs ELIFS;
non terminal SymbolElif ELIF;
non terminal SymbolElse ELSE;
non terminal SymbolSwitch SWITCH;
non terminal SymbolCaso CASO;
non terminal SymbolPred PRED;
non terminal SymbolScript SCRIPT;
non terminal SymbolMethodsBeforeMain SCRIPTBM;
non terminal SymbolMethodsAfterMain SCRIPTAM;
non terminal SymbolDimensiones DIMENSIONES;

precedence left OP_ADD, OP_SUB;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence right OP_POT;
precedence left OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
precedence left OP_AND, OP_OR;
precedence right OP_COND;
precedence left OP_MEMBER, AUX_MEMBER;

start with SCRIPT;
SCRIPT ::= SCRIPTBM:et1 SCRIPT:et2      {: RESULT = new SymbolScript(et1, et2); :}
        | SCRIPTAM:et                   {: RESULT = new SymbolScript(et); :}
        ;

SCRIPTBM ::= METHOD
        | DECS
        ;

SCRIPTAM ::= MAIN:et                    {: RESULT = new SymbolMethodsAfterMain(et); :}
        | SCRIPTAM SCRIPTBM
        ;

MAIN ::= KW_METHOD KW_VOID KW_MAIN LPAREN KW_STRING LBRACKET RBRACKET KW_ARGS RPAREN LBRACKET RBRACKET KW_ARGS RPAREN LKEY BODY:et RKEY {: RESULT = new SymbolMain(et); :}
        ;

METHOD ::= KW_METHOD TIPO_RETORNO ID LPAREN GETPARAMS RPAREN LKEY BODY RKEY
        ;

BODY ::= ELEMENTO_METODO:et1 BODY:et2   {: RESULT = new SymbolBody(et1, et2); :}
        |                               {: RESULT = new SymbolBody(); :}
        ;

TIPO_RETORNO ::= TIPO_VAR
        | KW_VOID
        ;

TIPO_VAR ::= KW_BOOL
        | KW_INT
        | KW_DOUBLE
        | KW_CHAR
        | KW_STRING
        ;

GETPARAMS ::= PARAM COMMA GETPARAMS
        | PARAM
        |
        ;

PARAM ::= TIPO_VAR ID
        ;

DECS ::= KW_CONST TIPO_VAR IDDECSLISTA ENDINSTR
        | TIPO_VAR IDDECSLISTA ENDINSTR
        | KW_CONST TIPO_VAR DIMENSIONES IDDECSLISTA ENDINSTR
        | TIPO_VAR DIMENSIONES IDDECSLISTA ENDINSTR
        | KW_TUPLE ID LKEY RKEY ENDINSTR
        | KW_TUPLE ID LKEY IDDECSLISTA RKEY ENDINSTR
        ;

DIMENSIONES ::= LBRACKET OPERAND RBRACKET DIMENSIONES
        | LBRACKET OPERAND RBRACKET
        ;

IDDECSLISTA ::= ID ASIG COMMA IDDECSLISTA
        | ID ASIG
        ;

ASIG ::= AS_ASSIGN OPERAND
        |
        ;

ELEMENTO_METODO ::= INSTR
        | LOOP
        | IF
        | SWITCH
        ;

INSTR ::= FCALL ENDINSTR
        | RETURN
        | DECS
        | ASIGS
        | SWAP
        ;

FCALL ::= FNAME LPAREN SETPARAMS RPAREN
        ;

FNAME ::= ID
        | KW_IN
        | KW_OUT
        | KW_WRITE
        | KW_READ
        ;

SETPARAMS ::= OPERANDSLISTA
        |
        ;

OPERANDSLISTA ::= OPERAND COMMA OPERANDSLISTA
        | OPERAND
        ;

RETURN ::= KW_RETURN ENDINSTR
        | KW_RETURN OPERAND ENDINSTR
        ;

SWAP ::= OPERAND OP_SWAP OPERAND ENDINSTR
        ;

ASIGS ::= IDASIGLISTA ENDINSTR
        ;

IDASIGLISTA ::= ID AS_OP OPERAND COMMA IDASIGLISTA
        | ID AS_OP OPERAND
        ;

AS_OP ::= AS_ASSIGN
        | AS_ADDA
        | AS_SUBA
        | AS_MULA
        | AS_DIVA
        | AS_POTA
        | AS_ANDA
        | AS_ORA
        ;

OPERAND ::= ATOMIC_EXPRESSION
        | FCALL
        | LPAREN OPERAND RPAREN
        | UNARY_EXPRESSION
        | BINARY_EXPRESSION
        | CONDITIONAL_EXPRESSION
        | OPERAND AUX_MEMBER LBRACKET OPERAND RBRACKET
        | OPERAND OP_MEMBER ID
        ;

UNARY_EXPRESSION ::= UNARY_OPERATOR OPERAND
        ;

BINARY_EXPRESSION ::= OPERAND BINARY_OPERATOR OPERAND
        ;

CONDITIONAL_EXPRESSION ::= OPERAND OP_COND OPERAND ARROW OPERAND
        ;

ATOMIC_EXPRESSION ::= ID
        | STRING
        | BOOL
        | INT
        | DOUBLE
        | CHAR
        ;

BINARY_OPERATOR ::= OP_ADD
        | OP_SUB
        | OP_MUL
        | OP_DIV
        | OP_MOD
        | OP_POT
        | OP_EQ
        | OP_BEQ
        | OP_BT
        | OP_LEQ
        | OP_LT
        | OP_NEQ
        | OP_AND
        | OP_OR
        ;

UNARY_OPERATOR ::= OP_NOT
        | OP_INC
        | OP_DEC
        | OP_PCT
        ;

LOOP ::= KW_LOOP LOOP_COND LKEY BODY RKEY
        | KW_DO LKEY BODY RKEY LOOP_COND ENDINSTR
        ;

LOOP_COND ::= OPERAND
        | DECS ENDINSTR OPERAND ENDINSTR OPERAND
        ;

IF ::= KW_IF OPERAND LKEY BODY RKEY ELIFS ELSE
        ;

ELIFS ::= ELIF ELIFS
        |
        ;

ELIF ::= KW_ELIF OPERAND LKEY BODY RKEY
        ;

ELSE ::= KW_ELSE LKEY BODY RKEY
        |
        ;

SWITCH ::= KW_SWITCH OPERAND RKEY CASO PRED LKEY
        ;

CASO ::= CASO KW_CASE ARROW BODY
        |
        ;

PRED ::= KW_CASE KW_DEFAULT ARROW BODY
        ;
