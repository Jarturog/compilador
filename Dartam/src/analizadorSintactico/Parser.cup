
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Arturo, Dani y Marta
 */
package analizadorSintactico;


import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

class Parser;

scan with {: 
    ComplexSymbol s = (ComplexSymbol) getScanner().next_token();
    return s;
:};

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:

    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) { 
        String causa = "" + cur_token.value;
        if (cur_token.sym == ParserSym.EOF) {
            causa = "No se ha encontrado metodo main. Sintaxis: \n"+
                "f void inicio(string[]argumentos){ # codigo # }\n";
        }
        System.err.println("No se ha podido recuperar del ultimo error. \nCausa: " + causa);
        done_parsing();
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    @Override
    public void syntax_error(Symbol cur_token){ 
        
        report_error("Error sintactico: ", cur_token);
    } 

    @Override
    public void report_error(String message, Object info) {
        if (cur_token.sym == ParserSym.EOF) {
            return;
        }
        if (info instanceof ComplexSymbol token) {
            List expected = expected_token_ids();
            String tokens = "";
            for (Object t : expected){
                tokens += ParserSym.terminalNames[(int)t] + ", ";
            }
            if (!tokens.isEmpty()) {
                tokens = "Se esperaba algun lexema de los siguientes tipos: " + tokens.substring(0, tokens.length() - 2) + ".\n";
            }
            System.err.println(message + "Desde la linea " + token.xleft.getLine() + " y columna " + token.xleft.getColumn() + " hasta la linea " + token.xright.getLine() + " y columna " + token.xright.getColumn() + ". \n"
                    + tokens + "Se ha encontrado '" + token.value + "' de tipo " + ParserSym.terminalNames[token.sym] + ".\n");  
        } else {
            System.err.println(message + "No se esperaba este componente\n: " +cur_token.value+".");  
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal: " + message, info);
        done_parsing();
    }

:}

terminal    OP_INC, OP_DEC, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD;
terminal    AS_ASSIGN, AS_ADDA, AS_SUBA, AS_MULA, AS_DIVA, AS_POTA, AS_ANDA, AS_ORA;
terminal    OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
terminal    OP_AND, OP_OR, OP_NOT;
terminal    OP_SWAP, OP_PCT, OP_POT, OP_COND, ARROW, OP_MEMBER;
terminal    KW_BOOL, KW_INT, KW_DOUBLE, KW_CHAR, KW_STRING, KW_VOID;
terminal    LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, ENDINSTR, COMMA;
terminal    KW_MAIN, KW_ARGS, KW_METHOD, KW_TUPLE, KW_CONST, KW_IF, KW_ELIF, KW_ELSE, KW_LOOP, KW_DO, KW_SWITCH, KW_RETURN, KW_IN, KW_OUT, KW_READ, KW_WRITE, KW_CASE, KW_DEFAULT;
terminal    AUX_MEMBER;

terminal    String              ID, STRING;
terminal    Boolean             BOOL;
terminal    Integer             INT;
terminal    Double              DOUBLE;
terminal    Character           CHAR;

non terminal SymbolBody BODY;
non terminal SymbolMain MAIN;
non terminal SymbolTipoRetorno TIPO_RETORNO;
non terminal SymbolTipoPrimitivo TIPO_PRIMITIVO;
non terminal SymbolTipo TIPO;
non terminal SymbolParams PARAMS;
non terminal SymbolParamsLista PARAMSLISTA;
non terminal SymbolDecs DECS;
non terminal SymbolDecAsigLista DEC_ASIG_LISTA;
non terminal SymbolAsigBasico ASIG_BASICO;
non terminal SymbolAsig ASIG;
non terminal SymbolMetodoElemento METODO_ELEMENTO;
non terminal SymbolInstr INSTR;
non terminal SymbolFCall FCALL;
non terminal SymbolMetodoNombre METODO_NOMBRE;
non terminal SymbolOperandsLista OPERANDS_LISTA;
non terminal SymbolReturn RETURN;
non terminal SymbolSwap SWAP;
non terminal SymbolAsigs ASIGS;
non terminal SymbolAsigOp ASIG_OP;
non terminal SymbolOperand OPERAND;
non terminal SymbolUnaryExpression UNARY_EXPRESSION;
non terminal SymbolBinaryExpression BINARY_EXPRESSION;
non terminal SymbolConditionalExpression CONDITIONAL_EXPRESSION;
non terminal SymbolAtomicExpression ATOMIC_EXPRESSION;
non terminal SymbolBinaryOperator BINARY_OPERATOR;
non terminal SymbolLUnaryOperator L_UNARY_OPERATOR;
non terminal SymbolRUnaryOperator R_UNARY_OPERATOR;
non terminal SymbolLoop LOOP;
non terminal SymbolLoopCond LOOP_COND;
non terminal SymbolIf IF;
non terminal SymbolElifs ELIFS;
non terminal SymbolElif ELIF;
non terminal SymbolElse ELSE;
non terminal SymbolSwitch SWITCH;
non terminal SymbolCaso CASO;
non terminal SymbolPred PRED;
non terminal SymbolScript SCRIPT;
non terminal SymbolScriptElemento SCRIPT_ELEMENTO;
non terminal SymbolDimensiones DIMENSIONES;
non terminal SymbolMiembrosTupla MIEMBROS_TUPLA;


precedence left OP_ADD, OP_SUB;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence right OP_POT;
precedence left OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
precedence left OP_AND, OP_OR;
precedence left OP_PCT;
precedence nonassoc OP_INC, OP_DEC; // si conflicto -> error
precedence right OP_COND;
precedence left OP_MEMBER, AUX_MEMBER;

start with SCRIPT;

SCRIPT ::= SCRIPT_ELEMENTO:et1 SCRIPT:et2       {: RESULT = new SymbolScript(et1, et2, et1xleft, et1xright); :}
        | MAIN:et                               {: RESULT = new SymbolScript(et, etxleft, etxright); :}
        ;

SCRIPT_ELEMENTO ::= KW_METHOD:et1 TIPO_RETORNO:et2 ID:et3 LPAREN PARAMS:et4 RPAREN LKEY BODY:et5 RKEY   {: RESULT = new SymbolScriptElemento(et2, et3, et4, et5, et1xleft, et1xright); :}
        | DECS:et                                                       {: RESULT = new SymbolScriptElemento(et, etxleft, etxright); :}
        | KW_TUPLE:et1 ID:et2 LKEY MIEMBROS_TUPLA:et3 RKEY ENDINSTR     {: RESULT = new SymbolScriptElemento(et2, et3, et1xleft, et1xright); :}
        ;

TIPO_RETORNO ::= TIPO:et            {: RESULT = new SymbolTipoRetorno(et, etxleft, etxright); :}
        | KW_VOID:et                    {: RESULT = new SymbolTipoRetorno(etxleft, etxright); :}
        ;

MIEMBROS_TUPLA ::= DECS:et1 MIEMBROS_TUPLA:et2         {:  RESULT = new SymbolMiembrosTupla(et1,et2, et1xleft, et1xright); :}
        |                                              {:  RESULT = new SymbolMiembrosTupla(); :}
        ;

MAIN ::= KW_METHOD KW_VOID KW_MAIN LPAREN KW_STRING LBRACKET RBRACKET KW_ARGS RPAREN LKEY BODY:et RKEY  {: RESULT = new SymbolMain(et, etxleft, etxright); :}
        | MAIN:et1 SCRIPT_ELEMENTO:et2     {: RESULT = new SymbolMain(et1,et2, et1xleft, et1xright); :}
        ;

BODY ::= METODO_ELEMENTO:et1 BODY:et2   {: RESULT = new SymbolBody(et1, et2, et1xleft, et1xright); :}
        |                               {: RESULT = new SymbolBody(); :}
        ;

TIPO ::= TIPO_PRIMITIVO
        | TIPO_PRIMITIVO DIMENSIONES
        | KW_TUPLE ID
        | KW_TUPLE ID DIMENSIONES
        ;

TIPO_PRIMITIVO ::= KW_BOOL                    {: RESULT = new SymbolTipoPrimitivo(ParserSym.KW_BOOL); :}
        | KW_INT                        {: RESULT = new SymbolTipoPrimitivo(ParserSym.KW_INT); :}
        | KW_DOUBLE                     {: RESULT = new SymbolTipoPrimitivo(ParserSym.KW_DOUBLE); :}
        | KW_CHAR                       {: RESULT = new SymbolTipoPrimitivo(ParserSym.KW_CHAR); :}
        | KW_STRING                     {: RESULT = new SymbolTipoPrimitivo(ParserSym.KW_STRING); :}
        ;

PARAMS ::= PARAMSLISTA:et                             {: RESULT = new SymbolParams(et, etxleft, etxright); :}   
        |                                             {: RESULT = new SymbolParams(); :}
        ;

PARAMSLISTA ::= TIPO:et1 ID COMMA PARAMSLISTA:et2           {: RESULT = new SymbolParamsLista(et1, et2, et1xleft, et1xright); :}
        | TIPO:et ID                          {: RESULT = new SymbolParamsLista(et, etxleft, etxright); :}
        ;

DECS ::= KW_CONST:et1 TIPO:et2 DEC_ASIG_LISTA:et3 ENDINSTR     {: RESULT = new SymbolDecs(true,et2,et3, et1xleft, et1xright); :}
        | TIPO:et1 DEC_ASIG_LISTA:et2 ENDINSTR                 {: RESULT = new SymbolDecs(false, et1,et2, et1xleft, et1xright); :}
        ; 

DIMENSIONES ::= LBRACKET OPERAND:et1 RBRACKET DIMENSIONES:et2   {: RESULT = new SymbolDimensiones(et1,et2, et1xleft, et1xright); :}
        | LBRACKET OPERAND:et1 RBRACKET                         {: RESULT = new SymbolDimensiones(et1, et1xleft, et1xright); :}
        ;

DEC_ASIG_LISTA ::= ID:et1 ASIG_BASICO:et2 COMMA DEC_ASIG_LISTA:et3       {: RESULT = new SymbolDecAsigLista(et1,et2,et3, et1xleft, et1xright); :}
        | ID:et1 ASIG_BASICO:et2                                   {: RESULT = new SymbolDecAsigLista(et1,et2, et1xleft, et1xright); :}
        ;

ASIG_BASICO ::= AS_ASSIGN OPERAND:et   {: RESULT = new SymbolAsigBasico(et, etxleft, etxright); :}
        |                       {: RESULT = new SymbolAsigBasico(); :}
        ;

METODO_ELEMENTO ::= INSTR:et    {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        | LOOP:et               {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        | IF:et                 {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        | SWITCH:et             {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        ;

INSTR ::= FCALL:et ENDINSTR    {: RESULT = new SymbolInstr(et,etxleft, etxright); :} 
        | RETURN:et            {: RESULT = new SymbolInstr(et,etxleft, etxright); :} 
        | DECS:et              {: RESULT = new SymbolInstr(et,etxleft, etxright); :}
        | ASIGS:et             {: RESULT = new SymbolInstr(et,etxleft, etxright); :}
        | SWAP:et              {: RESULT = new SymbolInstr(et,etxleft, etxright); :}
        ;

FCALL ::= METODO_NOMBRE:et1 LPAREN OPERANDS_LISTA:et2 RPAREN   {: RESULT = new SymbolFCall(et1, et2, et1xleft, et1xright); :}
        | METODO_NOMBRE:et1 LPAREN RPAREN   {: RESULT = new SymbolFCall(et1, et1xleft, et1xright); :}
        ;

METODO_NOMBRE ::= ID:et                 {: RESULT = new SymbolMetodoNombre(ParserSym.ID, et, etxleft, etxright); :}
        | KW_IN:et                      {: RESULT = new SymbolMetodoNombre(ParserSym.KW_IN, et, etxleft, etxright); :}
        | KW_OUT:et                     {: RESULT = new SymbolMetodoNombre(ParserSym.KW_OUT, et, etxleft, etxright); :}
        | KW_WRITE:et                   {: RESULT = new SymbolMetodoNombre(ParserSym.KW_WRITE, et, etxleft, etxright); :}
        | KW_READ:et                    {: RESULT = new SymbolMetodoNombre(ParserSym.KW_READ, et, etxleft, etxright); :}
        ;

OPERANDS_LISTA ::= OPERAND:et COMMA OPERANDS_LISTA:ol     {: RESULT = new SymbolOperandsLista(et, ol, etxleft, etxright); :}
        | OPERAND:et                                    {: RESULT = new SymbolOperandsLista(et, etxleft, etxright); :}
        ;

RETURN ::= KW_RETURN ENDINSTR                               {: :} //Con este que hacemos?
        | KW_RETURN OPERAND:et ENDINSTR                     {: RESULT = new SymbolReturn(et, etxleft, etxright); :}
        ;

SWAP ::= ID:et1 OP_SWAP ID:et2 ENDINSTR           {: RESULT = new SymbolSwap(et1, et2, et1xleft, et1xright); :}
        ;

ASIGS ::= ASIG:et1 COMMA ASIGS:et2                              {: RESULT = new SymbolAsigs(et1, et2, et1xleft, et1xright); :}
        | ASIG:et ENDINSTR                                      {: RESULT = new SymbolAsigs(et, etxleft, etxright); :}
        ;

ASIG ::= ID:et ASIG_OP:aop OPERAND:val                                                  {: RESULT = new SymbolAsig(et, aop, val, etxleft, etxright); :}
        | ID:et1 AUX_MEMBER LBRACKET OPERAND:et2 RBRACKET ASIG_OP:aop OPERAND:val  {: RESULT = new SymbolAsig(et1, et2, aop, val, et1xleft, et1xright); :}
        | ID:et1 OP_MEMBER ID:et2 ASIG_OP:aop OPERAND:val                          {: RESULT = new SymbolAsig(et1, et2, aop, val, et1xleft, et1xright); :}
        ;

ASIG_OP ::= AS_ASSIGN:et                {: RESULT = new SymbolAsigOp(ParserSym.AS_ASSIGN, et, etxleft, etxright); :}
        | AS_ADDA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_ADDA, et, etxleft, etxright); :}
        | AS_SUBA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_SUBA, et, etxleft, etxright); :}
        | AS_MULA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_MULA, et, etxleft, etxright); :}
        | AS_DIVA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_DIVA, et, etxleft, etxright); :}
        | AS_POTA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_POTA, et, etxleft, etxright); :}
        | AS_ANDA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_ANDA, et, etxleft, etxright); :}
        | AS_ORA:et                     {: RESULT = new SymbolAsigOp(ParserSym.AS_ORA, et, etxleft, etxright); :}
        ;

OPERAND ::= ATOMIC_EXPRESSION:et        {: RESULT = new SymbolOperand(et, etxleft, etxright); :}
        | FCALL:et                      {: RESULT = new SymbolOperand(et, etxleft, etxright); :}
        | LPAREN OPERAND:et RPAREN      {: RESULT = new SymbolOperand(et, etxleft, etxright); :}
        | UNARY_EXPRESSION:et           {: RESULT = new SymbolOperand(et, etxleft, etxright); :}
        | BINARY_EXPRESSION:et          {: RESULT = new SymbolOperand(et, etxleft, etxright); :}
        | CONDITIONAL_EXPRESSION:et     {: RESULT = new SymbolOperand(et, etxleft, etxright); :}
        | OPERAND:et1 AUX_MEMBER LBRACKET OPERAND:et2 RBRACKET  {: RESULT = new SymbolOperand(et1, et2, et1xleft, et1xright); :}
        | OPERAND:et1 OP_MEMBER ID:et2                     {: RESULT = new SymbolOperand(et1, et2, et1xleft, et1xright); :}
        ;

UNARY_EXPRESSION ::= L_UNARY_OPERATOR:et1 OPERAND:et2                       {: RESULT = new SymbolUnaryExpression(et1, et2, et1xleft, et1xright); :}
        | OPERAND:et1 R_UNARY_OPERATOR:et2                                  {: RESULT = new SymbolUnaryExpression(et1, et2, et1xleft, et1xright); :}
        ;

BINARY_EXPRESSION ::= OPERAND:et1 BINARY_OPERATOR:et2 OPERAND:et3        {: RESULT = new SymbolBinaryExpression(et1, et2, et3, et1xleft, et1xright); :}
        ;

CONDITIONAL_EXPRESSION ::= OPERAND:et1 OP_COND OPERAND:et2 ARROW OPERAND:et3   {: RESULT = new SymbolConditionalExpression(et1, et2, et3, et1xleft, et1xright);; :}
        ; 

ATOMIC_EXPRESSION ::= ID:et     {: RESULT = new SymbolAtomicExpression(et, etxleft, etxright); :}
        | STRING:et             {: RESULT = new SymbolAtomicExpression(et, etxleft, etxright); :}
        | BOOL:et               {: RESULT = new SymbolAtomicExpression(et, etxleft, etxright); :}
        | INT:et                {: RESULT = new SymbolAtomicExpression(et, etxleft, etxright); :}
        | DOUBLE:et             {: RESULT = new SymbolAtomicExpression(et, etxleft, etxright); :}
        | CHAR:et               {: RESULT = new SymbolAtomicExpression(et, etxleft, etxright); :}
        ;

BINARY_OPERATOR ::= OP_ADD:et   {: RESULT = new SymbolBinaryOperator(ParserSym.OP_ADD, et, etxleft, etxright); :}
        | OP_SUB:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_SUB, et, etxleft, etxright); :}
        | OP_MUL:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_MUL, et, etxleft, etxright); :}
        | OP_DIV:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_DIV, et, etxleft, etxright); :}
        | OP_MOD:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_MOD, et, etxleft, etxright); :}
        | OP_POT:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_POT, et, etxleft, etxright); :}
        | OP_EQ:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_EQ, et, etxleft, etxright); :}
        | OP_BEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_BEQ, et, etxleft, etxright); :}
        | OP_BT:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_BT, et, etxleft, etxright); :}
        | OP_LEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_LEQ, et, etxleft, etxright); :}
        | OP_LT:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_LT, et, etxleft, etxright); :}
        | OP_NEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_NEQ, et, etxleft, etxright); :}
        | OP_AND:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_AND, et, etxleft, etxright); :}
        | OP_OR:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_OR, et, etxleft, etxright); :}
        ;


L_UNARY_OPERATOR ::= OP_NOT:et    {: RESULT = new SymbolLUnaryOperator(ParserSym.OP_NOT, et , etxleft, etxright); :}
        | OP_INC:et             {: RESULT = new SymbolLUnaryOperator(ParserSym.OP_INC, et , etxleft, etxright); :}
        | OP_DEC:et             {: RESULT = new SymbolLUnaryOperator(ParserSym.OP_DEC, et , etxleft, etxright); :}
        ;

R_UNARY_OPERATOR ::= OP_PCT:et  {: RESULT = new SymbolRUnaryOperator(ParserSym.OP_PCT, et, etxleft, etxright); :}
        | OP_INC:et             {: RESULT = new SymbolRUnaryOperator(ParserSym.OP_INC, et, etxleft, etxright); :}
        | OP_DEC:et             {: RESULT = new SymbolRUnaryOperator(ParserSym.OP_DEC, et, etxleft, etxright); :}
        ;

LOOP ::= KW_LOOP:et1 LOOP_COND:et2 LKEY BODY:et3 RKEY                   {: RESULT = new SymbolLoop(et2, et3, et1xleft, et1xright); :}
        | KW_DO:et1 LKEY BODY:et2 RKEY LOOP_COND:et3 ENDINSTR           {: RESULT = new SymbolLoop(et2, et3, et1xleft, et1xright); :}
        ;

LOOP_COND ::= OPERAND:et                                                {: RESULT = new SymbolLoopCond(et, etxleft, etxright); :}
        | DECS:et1 ENDINSTR OPERAND:et2 ENDINSTR OPERAND:et3            {: RESULT = new SymbolLoopCond(et1, et2, et3, et1xleft, et1xright); :}
        ;

IF ::= KW_IF OPERAND:et1 LKEY BODY:et2 RKEY ELIFS:et3 ELSE:et4          {: RESULT = new SymbolIf(et1, et2, et3, et4, et1xleft, et1xright); :}
        ;

ELIFS ::= ELIF:et1 ELIFS:et2                        {: RESULT = new SymbolElifs(et1, et2, et1xleft, et1xright); :}
        |                                           {: RESULT = new SymbolElifs(); :}
        ;

ELIF ::= KW_ELIF OPERAND:et1 LKEY BODY:et2 RKEY     {: RESULT = new SymbolElif(et1, et2, et1xleft, et1xright); :}
        ;

ELSE ::= KW_ELSE LKEY BODY:et RKEY                  {: RESULT = new SymbolElse(et, etxleft, etxright); :}
        |                                           {: RESULT = new SymbolElse(); :}
        ;

SWITCH ::= KW_SWITCH OPERAND:et1 RKEY CASO:et2 PRED:et3 LKEY {: RESULT = new SymbolSwitch(et1, et2, et3, et1xleft, et1xright); :}
        ;   

CASO ::= CASO:et1 KW_CASE OPERAND:et2 ARROW BODY:et3 {: RESULT = new SymbolCaso(et1, et2, et3, et1xleft, et1xright); :}
        |                                            {: RESULT = new SymbolCaso(); :}
        ;

PRED ::= KW_CASE KW_DEFAULT ARROW BODY:et            {: RESULT = new SymbolPred(et, etxleft, etxright); :}
        ;
