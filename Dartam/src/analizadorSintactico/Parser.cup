
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Arturo, Dani y Marta
 */
package analizadorSintactico;


import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

class Parser;

scan with {: 
    ComplexSymbol s = (ComplexSymbol) getScanner().next_token();
    return s;
:};

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:

    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) { 
        String causa = "" + cur_token.value;
        if (cur_token.sym == ParserSym.EOF) {
            causa = "No se ha encontrado metodo main. Sintaxis: \n"+
                "f void inicio(string[]argumentos){ # codigo # }\n";
        }
        System.err.println("No se ha podido recuperar del ultimo error. \nCausa: " + causa);
        done_parsing();
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    @Override
    public void syntax_error(Symbol cur_token){ 
        
        report_error("Error sintactico: ", cur_token);
    } 

    @Override
    public void report_error(String message, Object info) {
        if (cur_token.sym == ParserSym.EOF) {
            return;
        }
        if (info instanceof ComplexSymbol token) {
            List expected = expected_token_ids();
            String tokens = "";
            for (Object t : expected){
                tokens += ParserSym.terminalNames[(int)t] + ", ";
            }
            if (!tokens.isEmpty()) {
                tokens = "Se esperaba algun lexema de los siguientes tipos: " + tokens.substring(0, tokens.length() - 2) + ".\n";
            }
            System.err.println(message + "Desde la linea " + token.xleft.getLine() + " y columna " + token.xleft.getColumn() + " hasta la linea " + token.xright.getLine() + " y columna " + token.xright.getColumn() + ". \n"
                    + tokens + "Se ha encontrado '" + token.value + "' de tipo " + ParserSym.terminalNames[token.sym] + ".\n");  
        } else {
            System.err.println(message + "No se esperaba este componente\n: " +cur_token.value+".");  
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error fatal: " + message, info);
        done_parsing();
    }

:}

terminal    OP_INC, OP_DEC, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD;
terminal    AS_ASSIGN, AS_ADDA, AS_SUBA, AS_MULA, AS_DIVA, AS_POTA, AS_ANDA, AS_ORA;
terminal    OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
terminal    OP_AND, OP_OR, OP_NOT;
terminal    OP_SWAP, OP_PCT, OP_POT, OP_COND, ARROW, OP_MEMBER;
terminal    KW_BOOL, KW_INT, KW_DOUBLE, KW_CHAR, KW_STRING, KW_VOID;
terminal    LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, ENDINSTR, COMMA;
terminal    KW_MAIN, KW_ARGS, KW_METHOD, KW_TUPLE, KW_CONST, KW_IF, KW_ELIF, KW_ELSE, KW_LOOP, KW_DO, KW_SWITCH, KW_RETURN, KW_IN, KW_OUT, KW_READ, KW_WRITE, KW_CASE, KW_DEFAULT;
terminal    AUX_MEMBER;

terminal    String              ID, STRING;
terminal    Boolean             BOOL;
terminal    Integer             INT;
terminal    Double              DOUBLE;
terminal    Character           CHAR;

non terminal SymbolBody BODY;
non terminal SymbolMain MAIN;
non terminal SymbolTipoRetorno TIPO_RETORNO;
non terminal SymbolTipoVar TIPO_VAR;
non terminal SymbolParams PARAMS;
non terminal SymbolParam PARAM;
non terminal SymbolParamsLista PARAMSLISTA;
non terminal SymbolDecs DECS;
non terminal SymbolIDDecsLista ID_DECS_LISTA;
non terminal SymbolAsig ASIG;
non terminal SymbolMetodoElemento METODO_ELEMENTO;
non terminal SymbolInstr INSTR;
non terminal SymbolFCall FCALL;
non terminal SymbolMetodoNombre METODO_NOMBRE;
non terminal SymbolOperandsLista OPERANDS_LISTA;
non terminal SymbolReturn RETURN;
non terminal SymbolSwap SWAP;
non terminal SymbolAsigs ASIGS;
non terminal SymbolIDAsigLista ID_ASIG_LISTA;
non terminal SymbolAsigOp ASIG_OP;
non terminal SymbolOperand OPERAND;
non terminal SymbolUnaryExpression UNARY_EXPRESSION;
non terminal SymbolBinaryExpression BINARY_EXPRESSION;
non terminal SymbolConditionalExpression CONDITIONAL_EXPRESSION;
non terminal SymbolAtomicExpression ATOMIC_EXPRESSION;
non terminal SymbolBinaryOperator BINARY_OPERATOR;
non terminal SymbolLUnaryOperator L_UNARY_OPERATOR;
non terminal SymbolRUnaryOperator R_UNARY_OPERATOR;
non terminal SymbolLoop LOOP;
non terminal SymbolLoopCond LOOP_COND;
non terminal SymbolIf IF;
non terminal SymbolElifs ELIFS;
non terminal SymbolElif ELIF;
non terminal SymbolElse ELSE;
non terminal SymbolSwitch SWITCH;
non terminal SymbolCaso CASO;
non terminal SymbolPred PRED;
non terminal SymbolScript SCRIPT;
non terminal SymbolScriptElemento SCRIPT_ELEMENTO;
non terminal SymbolDimensiones DIMENSIONES;
non terminal SymbolMiembrosTupla MIEMBROS_TUPLA;


precedence left OP_ADD, OP_SUB;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence right OP_POT;
precedence left OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
precedence left OP_AND, OP_OR;
precedence left OP_PCT;
precedence nonassoc OP_INC, OP_DEC; // si conflicto -> error
precedence right OP_COND;
precedence left OP_MEMBER, AUX_MEMBER;

start with SCRIPT;

SCRIPT ::= SCRIPT_ELEMENTO:et1 SCRIPT:et2       {: RESULT = new SymbolScript(et1, et2, et1xleft, et1xright); :}
        | MAIN:et                               {: RESULT = new SymbolScript(et, etxleft, etxright); :}
        ;

SCRIPT_ELEMENTO ::= KW_METHOD:et1 TIPO_RETORNO:et2 ID:et3 LPAREN PARAMS:et4 RPAREN LKEY BODY:et5 RKEY   {: RESULT = new SymbolScriptElemento(et2, et3, et4, et5, et1xleft, et1xright); :}
        | DECS:et                                                       {: RESULT = new SymbolScriptElemento(et, etxleft, etxright); :}
        | KW_TUPLE:et1 ID:et2 LKEY MIEMBROS_TUPLA:et3 RKEY ENDINSTR     {: RESULT = new SymbolScriptElemento(et2, et3, et1xleft, et1xright); :}
        ;

TIPO_RETORNO ::= TIPO_VAR:et            {: RESULT = new SymbolTipoRetorno(et, etxleft, etxright); :}
        | KW_VOID:et                    {: RESULT = new SymbolTipoRetorno(ParserSym.KW_VOID, etxleft, etxright); :}
        ;

MIEMBROS_TUPLA ::= DECS:et1 MIEMBROS_TUPLA:et2         {:  RESULT = new SymbolMiembrosTupla(et1,et2, et1xleft, et1xright); :}
        |                                              {:  RESULT = new SymbolMiembrosTupla(); :}
        ;

MAIN ::= KW_METHOD KW_VOID KW_MAIN LPAREN KW_STRING LBRACKET RBRACKET KW_ARGS RPAREN LKEY BODY:et RKEY  {: RESULT = new SymbolMain(et, etxleft, etxright); :}
        | MAIN:et1 SCRIPT_ELEMENTO:et2     {: RESULT = new SymbolMain(et1,et2, et1xleft, et1xright); :}
        ;

BODY ::= METODO_ELEMENTO:et1 BODY:et2   {: RESULT = new SymbolBody(et1, et2, et1xleft, et1xright); :}
        |                               {: RESULT = new SymbolBody(); :}
        ;
                                        
TIPO_VAR ::= KW_BOOL:et                    {: RESULT = new SymbolTipoVar(ParserSym.KW_BOOL, etxleft, etxright); :}
        | KW_INT:et                        {: RESULT = new SymbolTipoVar(ParserSym.KW_INT, etxleft, etxright); :}
        | KW_DOUBLE:et                     {: RESULT = new SymbolTipoVar(ParserSym.KW_DOUBLE, etxleft, etxright); :}
        | KW_CHAR:et                       {: RESULT = new SymbolTipoVar(ParserSym.KW_CHAR, etxleft, etxright); :}
        | KW_STRING:et                     {: RESULT = new SymbolTipoVar(ParserSym.KW_STRING, etxleft, etxright); :}
        ;


PARAMS ::= PARAMSLISTA:et                             {: RESULT = new SymbolParams(et, etxleft, etxright); :}   
        |                                             {: RESULT = new SymbolParams(); :}
        ;

PARAMSLISTA ::= PARAM:et1 COMMA PARAMSLISTA:et2           {: RESULT = new SymbolParamsLista(et1, et2, et1xleft, et1xright); :}
        | PARAM:et                           {: RESULT = new SymbolParamsLista(et, etxleft, etxright); :}
        ;

PARAM ::= TIPO_VAR:et1 ID:et2                   {: RESULT = new SymbolParam(et1,et2, et1xleft, et1xright); :}
        | TIPO_VAR:et1 DIMENSIONES:et2 ID:et3   {: RESULT = new SymbolParam(et1,et2,et3, et1xleft, et1xright); :}
        | KW_TUPLE:et1 ID:et2 ID:et3            {: RESULT = new SymbolParam(true,et1,et2, et1xleft, et1xright); :}
        ;

DECS ::= KW_CONST:et1 TIPO_VAR:et2 ID_DECS_LISTA:et3 ENDINSTR     {: RESULT = new SymbolDecs(true,et2,et3, et1xleft, et1xright); :}
        | TIPO_VAR:et1 ID_DECS_LISTA:et2 ENDINSTR                 {: RESULT = new SymbolDecs(false, et1,et2, et1xleft, et1xright); :}
        | KW_CONST:et1 TIPO_VAR:et2 DIMENSIONES:et3 ID_DECS_LISTA:et4 ENDINSTR {: RESULT = new SymbolDecs(true, et2, et3, et4, et1xleft, et1xright); :}
        | TIPO_VAR:et1 DIMENSIONES:et2 ID_DECS_LISTA:et3 ENDINSTR {: RESULT = new SymbolDecs(false, et1, et2, et3, et1xleft, et1xright); :}
        | KW_TUPLE:et1 ID:et2 ID_DECS_LISTA:et3 ENDINSTR          {: RESULT = new SymbolDecs(et1, et2, et3, true, et1xleft, et1xright); :} //REVISAR 
        ;

DIMENSIONES ::= LBRACKET OPERAND:et1 RBRACKET DIMENSIONES:et2   {: RESULT = new SymbolDimensiones(et1,et2, et1xleft, et1xright); :}
        | LBRACKET OPERAND:et1 RBRACKET                         {: RESULT = new SymbolDimensiones(et1, et1xleft, et1xright); :}
        ;

ID_DECS_LISTA ::= ID:et1 ASIG:et2 COMMA ID_DECS_LISTA:et3       {: RESULT = new SymbolIDDecsLista(et1,et2,et3, et1xleft, et1xright); :}
        | ID:et1 ASIG:et2                                   {: RESULT = new SymbolIDDecsLista(et1,et2, et1xleft, et1xright); :}
        ;

ASIG ::= AS_ASSIGN OPERAND:et   {: RESULT = new SymbolAsig(et, etxleft, etxright); :}
        |                       {: RESULT = new SymbolAsig(); :}
        ;

METODO_ELEMENTO ::= INSTR:et    {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        | LOOP:et               {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        | IF:et                 {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        | SWITCH:et             {: RESULT = new SymbolMetodoElemento(et, etxleft, etxright); :}
        ;

INSTR ::= FCALL:et ENDINSTR    {: RESULT = new SymbolInstr(et); :} 
        | RETURN:et            {: RESULT = new SymbolInstr(et); :}  //NO SE COMO HACER ESTE
        | DECS:et              {: RESULT = new SymbolInstr(et); :}
        | ASIGS:et             {: RESULT = new SymbolInstr(et); :}
        | SWAP:et              {: RESULT = new SymbolInstr(et); :}
        ;

FCALL ::= METODO_NOMBRE:et1 LPAREN OPERANDS_LISTA:et2 RPAREN   {: RESULT = new SymbolFCall(et1,et2); :}
        | METODO_NOMBRE:et1 LPAREN RPAREN   {: RESULT = new SymbolFCall(et1); :}
        ;

METODO_NOMBRE ::= ID:et                   {: RESULT = new SymbolMetodoNombre(ParserSym.ID); :}
        | KW_IN:et                      {: RESULT = new SymbolMetodoNombre(ParserSym.KW_IN); :}
        | KW_OUT:et                     {: RESULT = new SymbolMetodoNombre(ParserSym.KW_OUT); :}
        | KW_WRITE:et                   {: RESULT = new SymbolMetodoNombre(ParserSym.KW_WRITE); :}
        | KW_READ:et                    {: RESULT = new SymbolMetodoNombre(ParserSym.KW_READ); :}
        ;

OPERANDS_LISTA ::= OPERAND:et COMMA OPERANDS_LISTA:ol     {: RESULT = new SymbolOperandsLista(et, ol); :}
        | OPERAND:et                                    {: RESULT = new SymbolOperandsLista(et); :}
        ;

RETURN ::= KW_RETURN ENDINSTR
        | KW_RETURN OPERAND ENDINSTR
        ;

SWAP ::= OPERAND OP_SWAP OPERAND ENDINSTR
        ;

ASIGS ::= ID_ASIG_LISTA ENDINSTR
        ;

ID_ASIG_LISTA ::= ID ASIG_OP OPERAND COMMA ID_ASIG_LISTA
        | ID ASIG_OP OPERAND
        ;

ASIG_OP ::= AS_ASSIGN:et                {: RESULT = new SymbolAsigOp(ParserSym.AS_ASSIGN, et); :}
        | AS_ADDA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_ADDA, et); :}
        | AS_SUBA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_SUBA, et); :}
        | AS_MULA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_MULA, et); :}
        | AS_DIVA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_DIVA, et); :}
        | AS_POTA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_POTA, et); :}
        | AS_ANDA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_ANDA, et); :}
        | AS_ORA:et                     {: RESULT = new SymbolAsigOp(ParserSym.AS_ORA, et); :}
        ;

OPERAND ::= ATOMIC_EXPRESSION:et        {: RESULT = new SymbolOperand(et); :}
        | FCALL:et                      {: RESULT = new SymbolOperand(et); :}
        | LPAREN OPERAND:et RPAREN      {: RESULT = new SymbolOperand(et); :}
        | UNARY_EXPRESSION:et           {: RESULT = new SymbolOperand(et); :}
        | BINARY_EXPRESSION:et          {: RESULT = new SymbolOperand(et); :}
        | CONDITIONAL_EXPRESSION:et     {: RESULT = new SymbolOperand(et); :}
        | OPERAND:arr AUX_MEMBER LBRACKET OPERAND:idx RBRACKET  {: RESULT = new SymbolOperand(arr, idx); :}
        | OPERAND:tuple OP_MEMBER ID:member                     {: RESULT = new SymbolOperand(tuple, member); :}
        ;

UNARY_EXPRESSION ::= L_UNARY_OPERATOR:et OPERAND:op                       {: RESULT = new SymbolUnaryExpression(et, op); :}
        | OPERAND:op R_UNARY_OPERATOR:et
        ;

BINARY_EXPRESSION ::= OPERAND:op1 BINARY_OPERATOR:et OPERAND:op2        {: RESULT = new SymbolBinaryExpression(et, op1, op2); :}
        ;

CONDITIONAL_EXPRESSION ::= OPERAND:cond OP_COND OPERAND:op1 ARROW OPERAND:op2   {: RESULT = new SymbolConditionalExpression(cond, op1, op2);; :}
        ; 

ATOMIC_EXPRESSION ::= ID:et     {: RESULT = new SymbolAtomicExpression(et); :}
        | STRING:et             {: RESULT = new SymbolAtomicExpression(et); :}
        | BOOL:et               {: RESULT = new SymbolAtomicExpression(et); :}
        | INT:et                {: RESULT = new SymbolAtomicExpression(et); :}
        | DOUBLE:et             {: RESULT = new SymbolAtomicExpression(et); :}
        | CHAR:et               {: RESULT = new SymbolAtomicExpression(et); :}
        ;

BINARY_OPERATOR ::= OP_ADD:et   {: RESULT = new SymbolBinaryOperator(ParserSym.OP_ADD, et); :}
        | OP_SUB:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_SUB, et); :}
        | OP_MUL:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_MUL, et); :}
        | OP_DIV:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_DIV, et); :}
        | OP_MOD:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_MOD, et); :}
        | OP_POT:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_POT, et); :}
        | OP_EQ:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_EQ, et); :}
        | OP_BEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_BEQ, et); :}
        | OP_BT:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_BT, et); :}
        | OP_LEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_LEQ, et); :}
        | OP_LT:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_LT, et); :}
        | OP_NEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_NEQ, et); :}
        | OP_AND:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_AND, et); :}
        | OP_OR:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_OR, et); :}
        ;


L_UNARY_OPERATOR ::= OP_NOT:et    {: RESULT = new SymbolLUnaryOperator(ParserSym.OP_NOT, et); :}
        | OP_INC:et             {: RESULT = new SymbolLUnaryOperator(ParserSym.OP_INC, et); :}
        | OP_DEC:et             {: RESULT = new SymbolLUnaryOperator(ParserSym.OP_DEC, et); :}
        ;

R_UNARY_OPERATOR ::= OP_PCT:et             {: RESULT = new SymbolRUnaryOperator(ParserSym.OP_PCT, et); :}
        | OP_INC:et             {: RESULT = new SymbolRUnaryOperator(ParserSym.OP_INC, et); :}
        | OP_DEC:et             {: RESULT = new SymbolRUnaryOperator(ParserSym.OP_DEC, et); :}
        ;

LOOP ::= KW_LOOP LOOP_COND LKEY BODY RKEY
        | KW_DO LKEY BODY RKEY LOOP_COND ENDINSTR
        ;

LOOP_COND ::= OPERAND
        | DECS ENDINSTR OPERAND ENDINSTR OPERAND
        ;

IF ::= KW_IF OPERAND LKEY BODY RKEY ELIFS ELSE
        ;

ELIFS ::= ELIF ELIFS
        |
        ;

ELIF ::= KW_ELIF OPERAND LKEY BODY RKEY
        ;

ELSE ::= KW_ELSE LKEY BODY RKEY
        |
        ;

SWITCH ::= KW_SWITCH OPERAND RKEY CASO PRED LKEY
        ;

CASO ::= CASO KW_CASE OPERAND ARROW BODY
        |
        ;

PRED ::= KW_CASE KW_DEFAULT ARROW BODY
        ;
