
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Dani, Arturo y Marta
 */
package analizadorSintactico;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{ 
        report_error("Error síntactico irrecuperable en la Línea " + 
        (cur_token.left)+ " Columna "+cur_token.right+". Componente " + cur_token.value + 
        " no reconocido.", cur_token); 
        done_parsing();
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    @Override
    public void syntax_error(Symbol cur_token){ 
        report_error("Error Sintáctico en la Línea " + (cur_token.left) +
        " Columna "+cur_token.right+ ". No se esperaba este componente: " +cur_token.value+".", cur_token); 
    } 

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }

:}

/****
    També aquí es poden afegir accions a realitzar quan es requereix un token.
    scan with {:     next_token(); :}
**/

terminal    OP_INC, OP_DEC, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD;
terminal    AS_ASSIGN, AS_ADDA, AS_SUBA, AS_MULA, AS_DIVA, AS_POTA, AS_ANDA, AS_ORA;
terminal    OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
terminal    OP_AND, OP_OR, OP_NOT;
terminal    OP_SWAP, OP_PCT, OP_POT, OP_COND, ARROW;
terminal    KW_BOOL, KW_INT, KW_DOUBLE, KW_CHAR, KW_STRING, KW_VOID;
terminal    LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, ENDINSTR, COMMA, SQUOTE, DQUOTE, ENDLINE;
terminal    KW_MAIN, KW_ARGS, KW_CONST, KW_IF, KW_ELIF, KW_ELSE, KW_LOOP, KW_DO, KW_SWITCH, KW_RETURN, KW_IN, KW_OUT, KW_READ, KW_WRITE, KW_CASE, KW_DEFAULT;

terminal    String              ID, STRING;
terminal    Boolean             BOOL;
terminal    Integer             INT;
terminal    Double              DOUBLE;
terminal    Character           CHAR;

non terminal SymbolBody         BODY;
non terminal SymbolDecs         DECLARATIONS;
non terminal SymbolDec          DECLARATION;
non terminal SymbolDecCont      DECLARATION_COUNT;
non terminal SymbolMain         MAIN;
non terminal SymbolArgs         ARGS;
non terminal SymbolArg          ARG;
non terminal SymbolInstrs       INSTRUCTIONS;
non terminal SymbolInstr        INSTRUCTION;
non terminal SymbolFunc         FUNCTION;
non terminal SymbolType         TYPE;
non terminal SymbolVar          VARIABLE;
non terminal SymbolAssign       ASSIGNATION;
non terminal SymbolSwap         SYM_SWAP;
non terminal SymbolReturn       RETURN;
non terminal SymbolIn           IN;
non terminal SymbolOut          OUT;
non terminal SymbolOperation    OPERATION;
non terminal SymbolOperand      OPERAND;
non terminal SymbolValue        VALUE;
non terminal SymbolOp           OP;
non terminal SymbolIf           IF;
non terminal SymbolElse         ELSE;
non terminal SymbolLoop         LOOP;
non terminal SymbolFuncCall     FUNCTION_CALL;
non terminal SymbolParams       PARAMS;

// cosas que he quitado de Andreas:
// non terminal Object             FIXED_VALUE;
// non terminal SymbolArrSuff      ARRAY_SUFFIX;
// non terminal SymbolList         LIST, CONT_LIST;
// non terminal SymbolBase         HEADER_SEGMENT;

precedence left POT, MUL, DIV, MOD, ADD, SUB;
precedence left AND, OR;

S ::= S1 S
        | S2
        ;

S1 ::= METHOD
        | DECS ENDINSTR
        ;

S2 ::= MAIN
        | S2 S1
        ;

MAIN ::= KW_MAIN LPAREN KW_CHAR LBRACKET RBRACKET LBRACKET RBRACKET KW_ARGS RPAREN LKEY BODY RKEY
        ;

METHOD ::= TIPO_RETORNO ID LPAREN GETPARAMS RPAREN LKEY BODY RKEY
        ;

BODY ::= ELEMENTO_METODO BODY
        |
        ;

TIPO_RETORNO ::= TIPO_VAR
        | VOID
        ;

TIPO_VAR ::= BOOL
        | INT
        | DOUBLE
        | CHAR
        | STRING
        ;

GETPARAMS ::= PARAM COMMA GETPARAMS
        | PARAM
        |
        ;

PARAM ::= TIPO_VAR ID
        ;

DECS ::= CONST TIPO_VAR IDDECSLISTA
        ;

CONST ::= KW_CONST
        |
        ;

IDDECSLISTA ::= ID ASIG COMMA IDDECSLISTA
        | ID ASIG
        ;

ASIG ::= AS_ASSIGN OPERAND
        | 
        ;

ELEMENTO_METODO ::= INSTR
        | LOOP
        | IF
        | SWITCH
        ;

INSTR ::= FCALL ENDINSTR
        | STANDALONE_OP ENDINSTR
        ;

FCALL ::= FNAME LPAREN SETPARAMS RPAREN
        ;

FNAME ::= ID
        | IN
        | OUT
        | WRITE
        | READ
        ;

SETPARAMS ::= OPERANDSLISTA
        |
        ;

OPERANDSLISTA ::= OPERAND COMMA OPERANDSLISTA
        | OPERAND
        ;

STANDALONE_OP ::= RETURN
        | DECS
        | ASIGS
        | SWAP 
        ;

RETURN ::= KW_RETURN
        | KW_RETURN OPERATION
        ;

SWAP ::= OPERAND OP_SWAP OPERAND
        ;

ASIGS ::= IDASIGLISTA
        ;

IDASIGLISTA ::= ID AS_OP OPERAND COMMA IDASIGLISTA
        | ID AS_OP OPERAND
        ;

AS_OP ::= AS_ASSIGN
        | AS_ADDA
        | AS_SUBA
        | AS_MULA
        | AS_DIVA
        | AS_POTA
        | AS_ANDA 
        | AS_ORA
        ;

OPERAND ::= FCALL
        | UNARY_EXPRESSION
        | BINARY_EXPRESSION
        | CONDITIONAL_EXPRESSION
        | ATOMIC_EXPRESSION
        | LPAREN OPERAND RPAREN
        ;

UNARY_EXPRESSION ::= UNARY_OPERATOR OPERAND
        ;

BINARY_EXPRESSION ::= OPERAND BINARY_OPERATOR OPERAND
        ;

CONDITIONAL_EXPRESSION ::= OPERAND COND OPERAND ARROW OPERAND
        ;

ATOMIC_EXPRESSION ::= ID
        | STRING
        | BOOL
        | INT
        | DOUBLE
        | CHAR
        ;

CONCATENABLE_BINARY_OPERATOR ::= OP_ADD
        | OP_SUB
        | OP_MUL
        | OP_DIV
        | OP_MOD
        | OP_POT
        | OP_EQ
        | OP_BEQ
        | OP_BT
        | OP_LEQ
        | OP_LT
        | OP_NEQ
        | OP_AND
        | OP_OR
        ;

UNARY_OPERATOR ::= OP_NOT
        | OP_INC
        | OP_DEC
        | OP_PCT
        ;

LOOP ::= KW_LOOP LOOP_COND LKEY BODY RKEY
        | KW_DO LKEY BODY RKEY LOOP_COND ENDINSTR

LOOP_COND ::= OPERAND
        | DECS ENDINSTR OPERAND ENDINSTR OPERAND

IF ::= KW_IF OPERAND LKEY BODY_IF RKEY ELIFS ELSE
        ;

ELIFS ::= ELIF ELIFS
        |
        ;

ELIF ::= KW_ELIF OPERAND LKEY BODY_IF RKEY
        ;

ELSE ::= KW_ELSE LKEY BODY_IF RKEY
        |
        ;

SWITCH ::= KW_SWITCH OPERAND RKEY CASOS PRED LKEY
        ;

CASOS ::= CASO CASOS
        | CASO
        ;

CASO ::= KW_CASE ARROW BODY
        ;

PRED ::= KW_CASE KW_DEFAULT ARROW BODY
        ;