
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Marta, Arturo, Dani
 */
package analizadorSintactico;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    public void printVars(PrintStream out) {
        if (tsymbols.size() == 0) {
            out.println("No hi ha variables declarades");
        } else {
            String fmt = "%-8s: %f";
            tsymbols.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
    }

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la Línea " + 
        (s.left)+ " Columna "+s.right+". Componente " + s.value + 
        " no reconocido."); 
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    public void syntax_error(Symbol s){ 
        System.out.println("Error Sintáctico en la Línea " + (s.left) +
        " Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
    } 

:}

/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/

terminal    KW_MAIN;
terminal    KW_IF, KW_ELSE, KW_ELIF, KW_WHILEFOR, KW_DOLOOP, KW_SWITCH;
terminal    OP_NEG, OP_OR, OP_AND;
terminal    TYPE_DOUBLE, TYPE_INT, TYPE_CHAR, TYPE_BOOL, TYPE_VOID, TYPE_STRING, TYPE_CONST;
terminal    SYM_PARENIZQ, SYM_PARENDER, SYM_LLAVEIZQ, SYM_LLAVEER, SYM_BRACKETIZQ, SYM_BRACKETDER, SYM_ENDINSTR, SYM_COMA, SYM_COMILLASIMPLE, SYM_COMILLADOBLE, SYM_ASIG;
terminal    OP_SUM, OP_RES, OP_MUL, OP_DIV, OP_MOD, OP_EQ, OP_MAYOREQ, OP_MAYOR, OP_MENOREQ, OP_MENOR, OP_DIFERENT;

terminal    String  ID;
terminal    Integer VAL_ENTERO;
terminal    Double  VAL_REAL;
termianl    Boolean VAL_PROP;
terminal    Character   VAL_CHAR;
terminal    String  VAL_CADENA;

//Prueba!!!!!
non terminal SymbolBody         BODY;
non terminal SymbolDecs         DECLARATIONS;
non terminal SymbolDec          DECLARATION;
non terminal SymbolDecCont      CONT_DECLARATION;
non terminal SymbolMain         MAIN;
non terminal SymbolArgs         ARGS, MORE_ARGS;
non terminal SymbolArg          ARG;
non terminal SymbolInstrs       INSTRUCTIONS;
non terminal SymbolInstr        INSTRUCTION;
non terminal SymbolFunc         FUNCTION;
non terminal SymbolType         TYPE;
non terminal SymbolVar          VARIABLE;
non terminal SymbolAssign       ASSIGNATION;
non terminal SymbolSwap         SWAP;
non terminal SymbolReturn       RETURN;
non terminal SymbolIn           IN;
non terminal SymbolOut          OUT;
non terminal SymbolOperation    OPERATION;
non terminal SymbolOperand      OPERAND;
non terminal SymbolValue        VALUE;
non terminal SymbolOp           OP, OP_REL;
non terminal Object             FIXED_VALUE;
non terminal SymbolArrSuff      ARRAY_SUFFIX;
non terminal SymbolList         LIST, CONT_LIST;
non terminal SymbolIf           IF;
non terminal SymbolElse         ELSE;
non terminal SymbolLoop         LOOP;
non terminal SymbolFor          FOR;
non terminal SymbolFuncCall     FUNCTION_CALL;
non terminal SymbolParams       PARAMS, MORE_PARAMS;
non terminal SymbolBase         HEADER_SEGMENT;

precedence left  OP_MUL, OP_DIV, OP_MOD, OP_SUM, OP_RES;
precedence left  OP_AND, OP_OR;

start with OP;

OP ::= ADD                                                              {: RESULT = new SymbolOp(ParserSym.KW_ADD); :}
     | SUB                                                              {: RESULT = new SymbolOp(ParserSym.KW_SUB); :}
     | PROD                                                             {: RESULT = new SymbolOp(ParserSym.KW_PROD); :}
     | DIV                                                              {: RESULT = new SymbolOp(ParserSym.KW_DIV); :}
     | MOD                                                              {: RESULT = new SymbolOp(ParserSym.KW_MOD); :}
     | OR                                                               {: RESULT = new SymbolOp(ParserSym.KW_OR); :}
     | AND                                                              {: RESULT = new SymbolOp(ParserSym.KW_AND); :}
     | OP_REL:v                                                         {: RESULT = v; :}
     ;
OP_REL ::= IS_EQUAL                                                     {: RESULT = new SymbolOp(ParserSym.IS_EQUAL, true); :}
         | BIGGER                                                       {: RESULT = new SymbolOp(ParserSym.BIGGER, true); :}
         | BEQ                                                          {: RESULT = new SymbolOp(ParserSym.BEQ, true); :}
         | LESSER                                                       {: RESULT = new SymbolOp(ParserSym.LESSER, true); :}
         | LEQ                                                          {: RESULT = new SymbolOp(ParserSym.LEQ, true); :}
         | NEQ                                                          {: RESULT = new SymbolOp(ParserSym.NEQ, true); :}
         ;

VALUE ::= VARIABLE:v                                                    {: RESULT = new SymbolValue(v, vxleft.getLine(), vxleft.getColumn()); :}
        | FIXED_VALUE:v                                                 {: RESULT = new SymbolValue(v, vxleft.getLine(), vxleft.getColumn()); :}
        | FUNCTION_CALL:v                                               {: RESULT = new SymbolValue(v, vxleft.getLine(), vxleft.getColumn()); :}
        ;