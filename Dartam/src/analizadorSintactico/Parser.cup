
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Arturo, Dani y Marta
 */
package analizadorSintactico;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;
import java_cup.runtime.ComplexSymbolFactory.Location;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{ 
        report_error("Error síntactico irrecuperable en la Línea " + 
        (cur_token.left)+ " Columna "+cur_token.right+". Componente " + cur_token.value + 
        " no reconocido.", cur_token); 
        done_parsing();
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    @Override
    public void syntax_error(Symbol cur_token){ 
        if (cur_token.sym != ParserSym.error)
        report_error("Error Sintáctico en la Línea " + (cur_token.left) +
        " Columna "+cur_token.right+ ". No se esperaba este componente: " +cur_token.value+".", cur_token); 
    } 

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }

:}

/****
    També aquí es poden afegir accions a realitzar quan es requereix un token.
    scan with {:     next_token(); :}
**/

terminal    OP_INC, OP_DEC, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD;
terminal    AS_ASSIGN, AS_ADDA, AS_SUBA, AS_MULA, AS_DIVA, AS_POTA, AS_ANDA, AS_ORA;
terminal    OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
terminal    OP_AND, OP_OR, OP_NOT;
terminal    OP_SWAP, OP_PCT, OP_POT, OP_COND, ARROW, OP_MEMBER;
terminal    KW_BOOL, KW_INT, KW_DOUBLE, KW_CHAR, KW_STRING, KW_VOID;
terminal    LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, ENDINSTR, COMMA;
terminal    KW_MAIN, KW_ARGS, KW_METHOD, KW_TUPLE, KW_CONST, KW_IF, KW_ELIF, KW_ELSE, KW_LOOP, KW_DO, KW_SWITCH, KW_RETURN, KW_IN, KW_OUT, KW_READ, KW_WRITE, KW_CASE, KW_DEFAULT;
terminal    AUX_MEMBER;

terminal    String              ID, STRING;
terminal    Boolean             BOOL;
terminal    Integer             INT;
terminal    Double              DOUBLE;
terminal    Character           CHAR;

non terminal SymbolBody BODY;
non terminal SymbolMain MAIN;
non terminal SymbolMethod METHOD;
non terminal SymbolTypeRetorno TIPO_RETORNO;
non terminal SymbolTypeVar TIPO_VAR;
non terminal SymbolGetParams GETPARAMS;
non terminal SymbolParam PARAM;
non terminal SymbolDecs DECS;
non terminal SymbolIDDecsLista IDDECSLISTA;
non terminal SymbolAsig ASIG;
non terminal SymbolElementoMetodo ELEMENTO_METODO;
non terminal SymbolInstr INSTR;
non terminal SymbolFCall FCALL;
non terminal SymbolMethodName METHOD_NAME;
non terminal SymbolSetParams SETPARAMS;
non terminal SymbolOperandsLista OPERANDSLISTA;
non terminal SymbolReturn RETURN;
non terminal SymbolSwap SWAP;
non terminal SymbolAsigs ASIGS;
non terminal SymbolIDAsigLista IDASIGLISTA;
non terminal SymbolAsigOp ASIG_OP;
non terminal SymbolOperand OPERAND;
non terminal SymbolUnaryExpression UNARY_EXPRESSION;
non terminal SymbolBinaryExpression BINARY_EXPRESSION;
non terminal SymbolConditionalExpression CONDITIONAL_EXPRESSION;
non terminal SymbolAtomicExpression ATOMIC_EXPRESSION;
non terminal SymbolBinaryOperator BINARY_OPERATOR;
non terminal SymbolUnaryOperator UNARY_OPERATOR;
non terminal SymbolLoop LOOP;
non terminal SymbolLoopCond LOOP_COND;
non terminal SymbolIf IF;
non terminal SymbolElifs ELIFS;
non terminal SymbolElif ELIF;
non terminal SymbolElse ELSE;
non terminal SymbolSwitch SWITCH;
non terminal SymbolCaso CASO;
non terminal SymbolPred PRED;
non terminal SymbolScript SCRIPT;
non terminal SymbolMethodsBeforeMain SCRIPTBM;
non terminal SymbolMethodsAfterMain SCRIPTAM;
non terminal SymbolDimensiones DIMENSIONES;
non terminal GETPARAMS2, VARIOS_IDS;

precedence left OP_ADD, OP_SUB;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence right OP_POT;
precedence left OP_EQ, OP_BEQ, OP_BT, OP_LEQ, OP_LT, OP_NEQ;
precedence left OP_AND, OP_OR;
precedence right OP_COND;
precedence left OP_MEMBER, AUX_MEMBER;

start with SCRIPT;

SCRIPT ::= SCRIPTBM:et1 SCRIPT:et2      {: RESULT = new SymbolScript(et1, et2); :}
        | SCRIPTAM:et                   {: RESULT = new SymbolScript(et); :}
        ;

SCRIPTBM ::= METHOD
        | DECS
        ;

SCRIPTAM ::= MAIN:et                    {: RESULT = new SymbolMethodsAfterMain(et); :}
        | SCRIPTAM SCRIPTBM
        ;

MAIN ::= KW_METHOD KW_VOID KW_MAIN LPAREN KW_STRING LBRACKET RBRACKET KW_ARGS RPAREN LKEY BODY:et RKEY {: RESULT = new SymbolMain(); :}
        ;

METHOD ::= KW_METHOD TIPO_RETORNO ID LPAREN GETPARAMS RPAREN LKEY BODY RKEY
        ;

BODY ::= ELEMENTO_METODO:et1 BODY:et2   {: RESULT = new SymbolBody(et1, et2); :}
        |                               {: RESULT = new SymbolBody(); :}
        ;

TIPO_RETORNO ::= TIPO_VAR:et            {: RESULT = new SymbolTypeRetorno(et); :}
        | KW_VOID:et                    {: RESULT = new SymbolTypeRetorno(et); :}
        ;

TIPO_VAR ::= KW_BOOL
        | KW_INT
        | KW_DOUBLE
        | KW_CHAR
        | KW_STRING
        ;

GETPARAMS ::= GETPARAMS2
        |
        ;

GETPARAMS2 ::= PARAM COMMA GETPARAMS2
        | PARAM
        ;

PARAM ::= TIPO_VAR:et1 ID:et2           {: RESULT = new SymbolParam(et1, et2); :}
        ;

DECS ::= KW_CONST TIPO_VAR IDDECSLISTA ENDINSTR
        | TIPO_VAR IDDECSLISTA ENDINSTR
        | KW_CONST TIPO_VAR DIMENSIONES IDDECSLISTA ENDINSTR
        | TIPO_VAR DIMENSIONES IDDECSLISTA ENDINSTR
        | KW_TUPLE ID LKEY VARIOS_IDS RKEY ENDINSTR
        ;

DIMENSIONES ::= LBRACKET OPERAND RBRACKET DIMENSIONES
        | LBRACKET OPERAND RBRACKET
        ;

VARIOS_IDS ::= TIPO_VAR IDDECSLISTA ENDINSTR VARIOS_IDS
        |
        ;

IDDECSLISTA ::= ID ASIG COMMA IDDECSLISTA
        | ID ASIG
        ;

ASIG ::= AS_ASSIGN OPERAND:et   {: RESULT = new SymbolAsig(et); :}
        |                       {: RESULT = new SymbolAsig(); :}
        ;

ELEMENTO_METODO ::= INSTR
        | LOOP
        | IF
        | SWITCH
        ;

INSTR ::= FCALL ENDINSTR
        | RETURN
        | DECS
        | ASIGS
        | SWAP
        ;

FCALL ::= METHOD_NAME LPAREN SETPARAMS RPAREN
        ;

METHOD_NAME ::= ID:et                   {: RESULT = new SymbolMethodName(ParserSym.ID, et); :}
        | KW_IN:et                      {: RESULT = new SymbolMethodName(ParserSym.KW_IN, et); :}
        | KW_OUT:et                     {: RESULT = new SymbolMethodName(ParserSym.KW_OUT, et); :}
        | KW_WRITE:et                   {: RESULT = new SymbolMethodName(ParserSym.KW_WRITE, et); :}
        | KW_READ:et                    {: RESULT = new SymbolMethodName(ParserSym.KW_READ, et); :}
        ;

SETPARAMS ::= OPERANDSLISTA:et          {: RESULT = new SymbolSetParams(et); :}
        |                               {: RESULT = new SymbolSetParams(); :}
        ;

OPERANDSLISTA ::= OPERAND:et COMMA OPERANDSLISTA:ol     {: RESULT = new SymbolOperandsLista(et, ol); :}
        | OPERAND:et                                    {: RESULT = new SymbolOperandsLista(et); :}
        ;

RETURN ::= KW_RETURN ENDINSTR
        | KW_RETURN OPERAND ENDINSTR
        ;

SWAP ::= OPERAND OP_SWAP OPERAND ENDINSTR
        ;

ASIGS ::= IDASIGLISTA ENDINSTR
        ;

IDASIGLISTA ::= ID ASIG_OP OPERAND COMMA IDASIGLISTA
        | ID ASIG_OP OPERAND
        ;

ASIG_OP ::= AS_ASSIGN:et                {: RESULT = new SymbolAsigOp(ParserSym.AS_ASSIGN, et); :}
        | AS_ADDA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_ADDA, et); :}
        | AS_SUBA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_SUBA, et); :}
        | AS_MULA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_MULA, et); :}
        | AS_DIVA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_DIVA, et); :}
        | AS_POTA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_POTA, et); :}
        | AS_ANDA:et                    {: RESULT = new SymbolAsigOp(ParserSym.AS_ANDA, et); :}
        | AS_ORA:et                     {: RESULT = new SymbolAsigOp(ParserSym.AS_ORA, et); :}
        ;

OPERAND ::= ATOMIC_EXPRESSION:et        {: RESULT = new SymbolOperand(et); :}
        | FCALL:et                      {: RESULT = new SymbolOperand(et); :}
        | LPAREN OPERAND:et RPAREN      {: RESULT = new SymbolOperand(et); :}
        | UNARY_EXPRESSION:et           {: RESULT = new SymbolOperand(et); :}
        | BINARY_EXPRESSION:et          {: RESULT = new SymbolOperand(et); :}
        | CONDITIONAL_EXPRESSION:et     {: RESULT = new SymbolOperand(et); :}
        | OPERAND:arr AUX_MEMBER LBRACKET OPERAND:idx RBRACKET  {: RESULT = new SymbolOperand(arr, idx); :}
        | OPERAND:tuple OP_MEMBER ID:member                     {: RESULT = new SymbolOperand(tuple, member); :}
        ;

UNARY_EXPRESSION ::= UNARY_OPERATOR:et OPERAND:op                       {: RESULT = new SymbolUnaryExpression(et, op); :}
        ;

BINARY_EXPRESSION ::= OPERAND:op1 BINARY_OPERATOR:et OPERAND:op2        {: RESULT = new SymbolBinaryExpression(et, op1, op2); :}
        ;

CONDITIONAL_EXPRESSION ::= OPERAND:cond OP_COND OPERAND:op1 ARROW OPERAND:op2   {: RESULT = new SymbolConditionalExpression(cond, op1, op2);; :}
        ; 

ATOMIC_EXPRESSION ::= ID:et     {: RESULT = new SymbolAtomicExpression(et); :}
        | STRING:et             {: RESULT = new SymbolAtomicExpression(et); :}
        | BOOL:et               {: RESULT = new SymbolAtomicExpression(et); :}
        | INT:et                {: RESULT = new SymbolAtomicExpression(et); :}
        | DOUBLE:et             {: RESULT = new SymbolAtomicExpression(et); :}
        | CHAR:et               {: RESULT = new SymbolAtomicExpression(et); :}
        ;

BINARY_OPERATOR ::= OP_ADD:et   {: RESULT = new SymbolBinaryOperator(ParserSym.OP_ADD, et); :}
        | OP_SUB:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_SUB, et); :}
        | OP_MUL:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_MUL, et); :}
        | OP_DIV:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_DIV, et); :}
        | OP_MOD:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_MOD, et); :}
        | OP_POT:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_POT, et); :}
        | OP_EQ:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_EQ, et); :}
        | OP_BEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_BEQ, et); :}
        | OP_BT:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_BT, et); :}
        | OP_LEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_LEQ, et); :}
        | OP_LT:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_LT, et); :}
        | OP_NEQ:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_NEQ, et); :}
        | OP_AND:et             {: RESULT = new SymbolBinaryOperator(ParserSym.OP_AND, et); :}
        | OP_OR:et              {: RESULT = new SymbolBinaryOperator(ParserSym.OP_OR, et); :}
        ;


UNARY_OPERATOR ::= OP_NOT:et    {: RESULT = new SymbolUnaryOperator(ParserSym.OP_NOT, et); :}
        | OP_INC:et             {: RESULT = new SymbolUnaryOperator(ParserSym.OP_INC, et); :}
        | OP_DEC:et             {: RESULT = new SymbolUnaryOperator(ParserSym.OP_DEC, et); :}
        | OP_PCT:et             {: RESULT = new SymbolUnaryOperator(ParserSym.OP_PCT, et); :}
        ;

LOOP ::= KW_LOOP LOOP_COND LKEY BODY RKEY
        | KW_DO LKEY BODY RKEY LOOP_COND ENDINSTR
        ;

LOOP_COND ::= OPERAND
        | DECS ENDINSTR OPERAND ENDINSTR OPERAND
        ;

IF ::= KW_IF OPERAND LKEY BODY RKEY ELIFS ELSE
        ;

ELIFS ::= ELIF ELIFS
        |
        ;

ELIF ::= KW_ELIF OPERAND LKEY BODY RKEY
        ;

ELSE ::= KW_ELSE LKEY BODY RKEY
        |
        ;

SWITCH ::= KW_SWITCH OPERAND RKEY CASO PRED LKEY
        ;

CASO ::= CASO KW_CASE OPERAND ARROW BODY
        |
        ;

PRED ::= KW_CASE KW_DEFAULT ARROW BODY
        ;
