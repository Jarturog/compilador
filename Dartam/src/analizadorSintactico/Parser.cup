
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Marta, Arturo y Dani
 */
package analizadorSintactico;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;

import java_cup.runtime.*;

import analizadorSintactico.Symbols.*;

import java.io.PrintStream;
import java.util.HashMap;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    public void printVars(PrintStream out) {
        if (tsymbols.size() == 0) {
            out.println("No hi ha variables declarades");
        } else {
            String fmt = "%-8s: %f";
            tsymbols.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
    }


    public void printUsage(PrintStream out) {
        out.println("Calculadora 21780");
        out.println("=================\n");
        out.println("Utilització:\n------------");
        out.println("\tEn mode interactiu, les instruccions han d'acabar en \";\"");
        out.println("\tEn mode fitxer, el \";\" és opcional\n");

        out.println("Comandes:\n---------");
        out.println("\texit: acaba el programa");
        out.println("\tvars: mostra valor de totes les variables utilitzades");
        out.println("\thelp: mostra aquesta ajuda");
        out.println("\nOperacions aritmètiques:\n------------------------");
        
        out.println("\tEs poden fer sumes, restes, productes, divisions, mòduls i inverses");
        out.println("\t\t+ - * \\ % inv");
        out.println("\tEs poden fer assignacions a variables (es declaren automàticament)");
        out.println("\t\tvariable = valor");
        out.println("\tEl format dels nombres pot ser: real o enter.");
        out.println("\tEls enters es poden introduir en format decimal, binari, octal o hexadecimal");
        out.println("\t\tLes següents expressions representen el mateix valor");
        out.println("\t\t\t     binari: 0b1101");
        out.println("\t\t\t      octal: 0o15");
        out.println("\t\t\thexadecimal: 0xD");
        out.println("\t\t\t    decimal: 13");
        out.println("\t\t\t       real: 13.0");
        out.println("\t\t\t       real: .130E2");

        out.println();
        out.println("\tans: recupera el darrer valor calculat\n");
    }

    /**
     * Variable utilitzada per emmagatzemar el darrer valor calculat. 
     * Val 0 inicialment
     **/
    private double ans = 0;
    /**
     * Indicador de si s'ha detectat un error semàntic (true) o no (false);
     * Si una regla semàntica detecta un error, el notifica i posa el valor
     * a true, això limita el funcionament fins acabar de processar l'entrada,
     * moment en què es torna a posar a false.
     **/
    private boolean errorSemantic = false;


    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_error("Error sintàctic catastròfic", cur_token);
        done_parsing();        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("de sintaxis", cur_token);
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }


:}

/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/

terminal String ID;
terminal double  valor;
terminal ADD, SUB, MUL, DIV, MOD, LParen, RParen, INV, ASSIGN;
terminal EndCmd, EndCmdInteractive;
terminal HELPCMD, QUITCMD, DUMPVARS;
terminal ANS;

non terminal  Line, Linep, Cmd, EndLine;

non terminal  SymbolE   E;
non terminal  SymbolEp  Ep;
non terminal  SymbolT   T;
non terminal  SymbolTp  Tp;
non terminal  SymbolF   F;

precedence right ASSIGN; 
precedence left  ADD, SUB;
precedence left  MUL, DIV, MOD;

start with Line;

Line ::=  Cmd Linep       {:  :}
     ;

Linep ::= EndLine Cmd Linep {:  :}
     |                   {:  :}
     ;

EndLine ::= EndCmdInteractive EndCmd
      | EndCmd
      ;

Cmd ::= E:v              {: 
                            if (!errorSemantic) {
                               System.out.print("Resultat: " + v.value+"\n>>> ");
                               ans = (Double)v.value; // Recordar el valor
                            } else {
                               errorSemantic = false; // Desactivar l'estat d'error
                               System.out.print("\n>>> ");
                            }
                          :}
     | HELPCMD           {: printUsage(System.out); System.out.print("\n>>> "); :}
     | QUITCMD           {: done_parsing();                                     :}
     | DUMPVARS          {: printVars(System.out); System.out.print("\n>>> ");  :}
     | error EndCmd      {: /* Si hi ha un error botar-se tota la línia de comanda  */
                            /* En recuperar de l'error s'ha de continuar com si res */
                            System.out.print("\n>>> ");
                          :}
     ;

E ::=  T:v1 Ep:v2        {: if (errorSemantic) {
                                RESULT = new SymbolE();
                            } else {
                                RESULT = new SymbolE((Double)v1.value, v2);
                            }
                          :}
     ;

Ep ::= ADD T:v1 Ep:v2    {: if (errorSemantic) {
                                RESULT = new SymbolEp();
                            } else {
                                RESULT = new SymbolEp(ParserSym.ADD, (Double)v1.value, v2);
                            }
                          :}
     | SUB T:v1 Ep:v2    {: if (errorSemantic) {
                                RESULT = new SymbolEp();
                            } else {
                                RESULT = new SymbolEp(ParserSym.SUB, (Double)v1.value, v2);
                            }
                          :} 
     |                   {: RESULT = new SymbolEp();                            :}
     ;


T ::=  F:v1 Tp:v2        {: if (errorSemantic) {
                                RESULT = new SymbolT();
                            } else {
                                RESULT = new SymbolT((Double)v1.value, v2);     
                            }
                          :}
     ;

Tp ::= MUL F:v1 Tp:v2    {:  if (errorSemantic) {
                                RESULT = new SymbolTp();
                            } else {
                                RESULT = new SymbolTp(ParserSym.MUL, (Double)v1.value, v2); 
                            }
                          :}
     | DIV F:v1 Tp:v2    {:  if (errorSemantic) {
                                RESULT = new SymbolTp();
                            } else {
                                RESULT = new SymbolTp(ParserSym.DIV, (Double)v1.value, v2);   
                            }
                          :}
     | MOD F:v1 Tp:v2    {:  if (errorSemantic) {
                                RESULT = new SymbolTp();
                            } else {
                                RESULT = new SymbolTp(ParserSym.MOD, (Double)v1.value, v2);   
                            }
                          :}
     |                   {:  RESULT = new SymbolTp();                           :}
     ;

F ::= LParen E:v RParen  {: RESULT = new SymbolF((Double)v.value);              :}
     | ID:v1 ASSIGN E:v2 {: 
                            if (errorSemantic) {
                                RESULT = new SymbolF();
                            } else {
                                addSymbol(v1, (Double)v2.value); 
                                RESULT =  new SymbolF((Double)v2.value);  
                            }
                          :} 
     | valor:v           {: RESULT = new SymbolF(v);                            :}
     | ADD E:v           {: RESULT = new SymbolF((Double)v.value);  :}  
     | SUB E:v           {: RESULT = new SymbolF(-1.0 * (Double)v.value); :}
     | INV E:v           {: RESULT = new SymbolF(1.0 / (Double)v.value);        :}
     | ID:v              {: Double value = getSymbolValue(v);
                            if (value == null) {
                                report_error("Undefined id \""+v+"\"", v);
                                errorSemantic = true;
                                RESULT = new SymbolF();
                            } else {
                                RESULT = new SymbolF(value);
                            }
                          :}
     | ANS:v             {: RESULT = new SymbolF(ans);                          :}
     ;
