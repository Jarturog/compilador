
/**
 Per compilar aquest fitxer s'ha d'haver instal·lat JavaCup

  java -jar java-cup-11b.jar Parser.cup

alternativament

  java -classpath path_fins_java-cup-11b.jar java_cup.Main Parser.cup

 **/

/**
 * Assignatura 21780 - Compiladors
 * Estudis: Grau en Informàtica 
 * Itinerari: Intel·ligència Artificial i Computació
 *
 * Equipo: Dani, Arturo y Marta
 */
package analizadorSintactico;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.*;
import analizadorSintactico.symbols.*;
import java.io.PrintStream;
import java.util.HashMap;

class Parser;

/**
 ** Aquí es podria posar un codi 'ad hoc' però en aquest cas no és necessari.
**/
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    private HashMap<String, Double>tsymbols = new HashMap<>();

    public Double getSymbolValue(String id) {
         return tsymbols.get(id);
    }

    public void addSymbol(String id, Double value) {
        if (tsymbols.get(id) == null) {
            tsymbols.put(id, value);
        } else {
            tsymbols.replace(id, value);
        }
    }

    public void printVars(PrintStream out) {
        if (tsymbols.size() == 0) {
            out.println("No hi ha variables declarades");
        } else {
            String fmt = "%-8s: %f";
            tsymbols.forEach((k,v) -> out.println(String.format(fmt,k,v)));
        }
    }

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
    **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la Línea " + 
        (s.left)+ " Columna "+s.right+". Componente " + s.value + 
        " no reconocido."); 
    }  

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
    **/ 
    public void syntax_error(Symbol s){ 
        System.out.println("Error Sintáctico en la Línea " + (s.left) +
        " Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
    } 

:}

/****
    També aquí es poden afegir accions a realitzar quan es requereix un token.
    scan with {:     next_token(); :}
**/

terminal    INC, DEC, ADD, SUB, MUL, DIV, MOD;
terminal    ADDA, SUBA, MULA, DIVA, POTA, ANDA, ORA;
terminal    EQ, BEQ, BT, LEQ, LT, NEQ;
terminal    AND, OR, NOT;
terminal    ASSIGN, SWAP, PCT, POT, COND, ARROW;
terminal    BOOL, INT, DOUBLE, CHAR, STRING, VOID;
terminal    LPAREN, RPAREN, LKEY, RKEY, LBRACKET, RBRACKET, ENDINSTR, COMMA, SQUOTE, DQUOTE, ENDLINE;
terminal    KW_MAIN, CONST, KW_IF, ELIF, KW_ELSE, KW_LOOP, DO, SWITCH, KW_RETURN, KW_IN, KW_OUT, CASE;

terminal     String             V_ID, V_STRING;
terminal     Boolean            V_BOOL;
terminal     Integer            V_INT;
terminal     Double             V_DOUBLE;
terminal     Character          V_CHAR;

non terminal SymbolBody         BODY;
non terminal SymbolDecs         DECLARATIONS;
non terminal SymbolDec          DECLARATION;
non terminal SymbolDecCont      DECLARATION_COUNT;
non terminal SymbolMain         MAIN;
non terminal SymbolArgs         ARGS;
non terminal SymbolArg          ARG;
non terminal SymbolInstrs       INSTRUCTIONS;
non terminal SymbolInstr        INSTRUCTION;
non terminal SymbolFunc         FUNCTION;
non terminal SymbolType         TYPE;
non terminal SymbolVar          VARIABLE;
non terminal SymbolAssign       ASSIGNATION;
non terminal SymbolSwap         SYM_SWAP;
non terminal SymbolReturn       RETURN;
non terminal SymbolIn           IN;
non terminal SymbolOut          OUT;
non terminal SymbolOperation    OPERATION;
non terminal SymbolOperand      OPERAND;
non terminal SymbolValue        VALUE;
non terminal SymbolOp           OP;
non terminal SymbolIf           IF;
non terminal SymbolElse         ELSE;
non terminal SymbolLoop         LOOP;
non terminal SymbolFuncCall     FUNCTION_CALL;
non terminal SymbolParams       PARAMS;

// cosas que he quitado de Andreas:
// non terminal Object             FIXED_VALUE;
// non terminal SymbolArrSuff      ARRAY_SUFFIX;
// non terminal SymbolList         LIST, CONT_LIST;
// non terminal SymbolBase         HEADER_SEGMENT;

precedence left MUL, DIV, MOD, ADD, SUB;
precedence left AND, OR;

OPERATION ::= V_INT:v1 OP V_INT:v2                          {: RESULT = new SymbolAdd(v1,v2); :} ;