KW_METHOD: f
TYPE_VOID: vacio
KW_MAIN: inicio
SYM_LPAREN: (
SYM_RPAREN: )
SYM_LKEY: {
TYPE_INT: ent
ID: a
OP_ASIG: :
ID: product
SYM_LPAREN: (
VAL_DECIMAL: 2
SYM_COMMA: ,
VAL_DECIMAL: 3
SYM_RPAREN: )
SYM_ENDINSTR: ;
KW_IF: si
ID: a
OP_EQ: =
VAL_DECIMAL: 6
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "2 * 3 = 6"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "6 est√° almacenado en 'a'"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_ELSE: no
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "ERROR: 2*3 no ha dado 6"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
SYM_RKEY: }
KW_METHOD: f
TYPE_INT: ent
ID: product
SYM_LPAREN: (
TYPE_INT: ent
ID: x
SYM_COMMA: ,
TYPE_INT: ent
ID: y
SYM_RPAREN: )
SYM_LKEY: {
TYPE_INT: ent
ID: z
OP_ASIG: :
VAL_DECIMAL: 0
SYM_ENDINSTR: ;
KW_WHILE: loop
ID: x
OP_DIFERENT: /=
VAL_DECIMAL: 0
SYM_LKEY: {
KW_IF: si
SYM_LPAREN: (
ID: x
OP_MOD: \
VAL_DECIMAL: 2
SYM_RPAREN: )
OP_EQ: =
VAL_DECIMAL: 1
SYM_LKEY: {
ID: z
OP_SUM_ASSIGNMENT: +:
ID: y
SYM_ENDINSTR: ;
SYM_RKEY: }
ID: y
OP_MUL_ASSIGNMENT: *:
VAL_DECIMAL: 2
SYM_ENDINSTR: ;
ID: x
OP_DIV_ASSIGNMENT: /:
VAL_DECIMAL: 2
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_RETURN: pop
ID: z
SYM_ENDINSTR: ;
SYM_RKEY: }
