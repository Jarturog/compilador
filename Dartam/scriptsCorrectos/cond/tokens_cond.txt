KW_METHOD: f
TYPE_VOID: vacio
KW_MAIN: inicio
SYM_LPAREN: (
SYM_RPAREN: )
SYM_LKEY: {
ID: parte1
SYM_LPAREN: (
SYM_RPAREN: )
SYM_ENDINSTR: ;
ID: parte2
SYM_LPAREN: (
SYM_RPAREN: )
SYM_ENDINSTR: ;
ID: parte3
SYM_LPAREN: (
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_METHOD: f
TYPE_VOID: vacio
ID: parte1
SYM_LPAREN: (
SYM_RPAREN: )
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "PARTE 1"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "Muestra de un mal uso del switch (sin break)"
SYM_RPAREN: )
SYM_ENDINSTR: ;
TYPE_INT: ent
ID: a
OP_ASIG: :
SYM_LPAREN: (
VAL_DECIMAL: 3
OP_EQ: =
VAL_DECIMAL: 3
SYM_RPAREN: )
OP_COND: ?
VAL_DECIMAL: 3
OP_ARROW: ->
VAL_DECIMAL: 4
SYM_ENDINSTR: ;
KW_IF: si
ID: a
OP_EQ: =
VAL_DECIMAL: 3
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "a: 3"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_ELIF: sino
ID: a
OP_EQ: =
VAL_DECIMAL: 4
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "a: 4"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
ID: switch
SYM_LPAREN: (
ID: a
SYM_RPAREN: )
SYM_ENDINSTR: ;
TYPE_INT: ent
ID: b
OP_ASIG: :
VAL_DECIMAL: 2
OP_POTENCIA: **
VAL_DECIMAL: 3
SYM_ENDINSTR: ;
KW_IF: si
ID: b
OP_EQ: =
VAL_DECIMAL: 8
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "b: 8"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
ID: switch
SYM_LPAREN: (
ID: b
SYM_RPAREN: )
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: ""
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_METHOD: f
TYPE_VOID: vacio
ID: parte2
SYM_LPAREN: (
SYM_RPAREN: )
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "PARTE 2"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "Muestra de un buen uso del switch (con break)"
SYM_RPAREN: )
SYM_ENDINSTR: ;
TYPE_INT: ent
ID: a
OP_ASIG: :
SYM_LPAREN: (
VAL_DECIMAL: 3
OP_EQ: =
VAL_DECIMAL: 3
SYM_RPAREN: )
OP_COND: ?
VAL_DECIMAL: 3
OP_ARROW: ->
VAL_DECIMAL: 4
SYM_ENDINSTR: ;
KW_IF: si
ID: a
OP_EQ: =
VAL_DECIMAL: 3
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "a: 3"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_ELIF: sino
ID: a
OP_EQ: =
VAL_DECIMAL: 4
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "a: 4"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
ID: switchConBreak
SYM_LPAREN: (
ID: a
SYM_RPAREN: )
SYM_ENDINSTR: ;
TYPE_INT: ent
ID: b
OP_ASIG: :
VAL_DECIMAL: 2
OP_POTENCIA: **
VAL_DECIMAL: 3
SYM_ENDINSTR: ;
KW_IF: si
ID: b
OP_EQ: =
VAL_DECIMAL: 8
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "b: 8"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
ID: switchConBreak
SYM_LPAREN: (
ID: b
SYM_RPAREN: )
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: ""
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_METHOD: f
TYPE_VOID: vacio
ID: parte3
SYM_LPAREN: (
SYM_RPAREN: )
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "PARTE 3"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "Muestra de un buen uso de si, sino y no"
SYM_RPAREN: )
SYM_ENDINSTR: ;
TYPE_INT: ent
ID: num1
OP_ASIG: :
VAL_DECIMAL: 1
SYM_COMMA: ,
ID: num2
OP_ASIG: :
VAL_DECIMAL: 1
SYM_ENDINSTR: ;
TYPE_INT: ent
ID: aux1
OP_ASIG: :
OP_DEC: --
ID: num1
SYM_ENDINSTR: ;
TYPE_INT: ent
ID: aux2
OP_ASIG: :
ID: num2
OP_DEC: --
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "num1:1    num2:1    aux1:--num1    aux2:num2--"
SYM_RPAREN: )
SYM_ENDINSTR: ;
KW_IF: si
SYM_LPAREN: (
ID: aux1
OP_EQ: =
VAL_DECIMAL: 0
SYM_RPAREN: )
OP_AND: &
SYM_LPAREN: (
ID: num1
OP_EQ: =
VAL_DECIMAL: 0
SYM_RPAREN: )
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "num1: 0 (aux1: 0)"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_IF: si
SYM_LPAREN: (
ID: aux2
OP_EQ: =
VAL_DECIMAL: 1
SYM_RPAREN: )
OP_AND: &
SYM_LPAREN: (
ID: num1
OP_EQ: =
VAL_DECIMAL: 0
SYM_RPAREN: )
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "num2: 0 (aux2: 1)"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
ID: ifs
SYM_LPAREN: (
ID: aux1
SYM_RPAREN: )
SYM_ENDINSTR: ;
ID: ifs
SYM_LPAREN: (
ID: aux2
SYM_RPAREN: )
SYM_ENDINSTR: ;
SHOW: show
SYM_LPAREN: (
VAL_CADENA: ""
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_METHOD: f
TYPE_VOID: vacio
ID: switch
SYM_LPAREN: (
TYPE_INT: ent
ID: v
SYM_RPAREN: )
SYM_LKEY: {
ID: v
OP_MOD_ASSIGNMENT: \:
VAL_DECIMAL: 2
SYM_ENDINSTR: ;
KW_SWITCH: select
ID: v
SYM_LKEY: {
KW_CASE: caso
VAL_DECIMAL: 0
OP_ARROW: ->
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "El numero introducido es par"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_CASE: caso
VAL_DECIMAL: 1
OP_ARROW: ->
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "El numero introducido es impar"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_CASE: caso
KW_DEFAULT: _
OP_ARROW: ->
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "Error, el numero no es par ni impar"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
SYM_RKEY: }
SYM_RKEY: }
KW_METHOD: f
TYPE_VOID: vacio
ID: switchConBreak
SYM_LPAREN: (
TYPE_INT: ent
ID: v
SYM_RPAREN: )
SYM_LKEY: {
ID: v
OP_MOD_ASSIGNMENT: \:
VAL_DECIMAL: 2
SYM_ENDINSTR: ;
KW_SWITCH: select
ID: v
SYM_LKEY: {
KW_CASE: caso
VAL_DECIMAL: 0
OP_ARROW: ->
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "El numero introducido es par"
SYM_RPAREN: )
SYM_ENDINSTR: ;
KW_BREAK: parar
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_CASE: caso
VAL_DECIMAL: 1
OP_ARROW: ->
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "El numero introducido es impar"
SYM_RPAREN: )
SYM_ENDINSTR: ;
KW_BREAK: parar
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_CASE: caso
KW_DEFAULT: _
OP_ARROW: ->
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "Error, el numero no es par ni impar"
SYM_RPAREN: )
SYM_ENDINSTR: ;
KW_BREAK: parar
SYM_ENDINSTR: ;
SYM_RKEY: }
SYM_RKEY: }
SYM_RKEY: }
KW_METHOD: f
TYPE_VOID: vacio
ID: ifs
SYM_LPAREN: (
TYPE_INT: ent
ID: v
SYM_RPAREN: )
SYM_LKEY: {
ID: v
OP_MOD_ASSIGNMENT: \:
VAL_DECIMAL: 2
SYM_ENDINSTR: ;
KW_IF: si
ID: v
OP_EQ: =
VAL_DECIMAL: 0
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "El numero introducido es par"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_ELIF: sino
ID: v
OP_EQ: =
VAL_DECIMAL: 1
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "El numero introducido es impar"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
KW_ELSE: no
SYM_LKEY: {
SHOW: show
SYM_LPAREN: (
VAL_CADENA: "Error, el numero no es par ni impar"
SYM_RPAREN: )
SYM_ENDINSTR: ;
SYM_RKEY: }
SYM_RKEY: }
